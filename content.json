{"meta":{"title":"Episode Zhang's Blog","subtitle":"世界之底的某处自留地","description":"记录想记录的一切","author":"Episode Zhang","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2024-01-02T15:43:26.000Z","updated":"2024-01-02T15:43:08.730Z","comments":true,"path":"aboutme/index.html","permalink":"http://example.com/aboutme/index.html","excerpt":"","text":"👋 先打个招呼吧，你好！很高兴你能阅读我的博客~ 👉 放在前面，关于为什么想写博客：第一篇Blog 😉 更多基本信息： 00年，浙江人，He&#x2F;Him，期望并正在实践着去成为一个包容的人; 23年双非财经院校本科毕业，专业大数据; 现从事软件开发工作，主要负责项目交付中的后端，以及内部自研GIS平台与组件的开发和维护； 喜欢写代码，会觉得实现自己的想法很有意思; 😇 我的价值观：尊重、包容、理性、文明、自由."},{"title":"tag","date":"2022-07-06T12:54:52.000Z","updated":"2022-07-06T16:31:08.209Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"2023年终总结","slug":"2023年终总结","date":"2024-01-02T15:20:07.000Z","updated":"2024-01-02T15:38:05.580Z","comments":true,"path":"2024/01/02/2023年终总结/","link":"","permalink":"http://example.com/2024/01/02/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"0. 引子其实早在12月初就已经有了动笔23年年终总结的念头了，但是总感觉23年剩下的最后的日子里还会有新的盼望与涟漪，不想就此对整年盖棺定论，又或者是懒和拖延，就到了24年1月1日才开始着手写这份年终总结了。如果用一个词来概括过去的23年，我想是——“杂乱”：23年最开始的那几天，抱着“阳”后初愈的身体，放弃了考研，来到了现在所在的公司进行实习，负责一项全新业务0-1的探索和验证；中途又经历了转正、公司大量裁员、部门架构调整、业务变动，切身感受到了所谓的“寒气”；开启了个人在杭州的全新生活，告别了一些人，也遇到了新的人……2023年，便是我试图从“杂乱”中理出头绪，用软件工程的话来讲，便是管理“生活”的复杂度的一年。 接下来，我想从下面的几个角度 事：在2023年一年里，我在工作和生活中做了哪些事情； 人：2023年令我印象深刻的人，以及我和他们的故事； 情感：2023年我如何将自我的希冀与盼望投向另一个个体，以及得出的结论； 反思与目标：对2023年全年所经历的人事进行回顾和反思，并且确定24年的目标与期望； 来概括一下23年做了哪些事，以及有怎样的收获和感想。 1. 事1.1 工作3月份之前，主要是熟悉web gis那一套技术栈，包括前端三件套基础加上cesium.js，mapbox.js这一类web gis开发中常用的包。为了解决前端加载倾斜摄影慢的问题，研究了一下如何使用nginx作为客户端缓存，以及对应的请求策略。因为之前完全没有web开发的背景知识，所以经此一役算是算是快速入门web开发了。 3月份-7月份则开始研究数字孪生相关的领域知识并且产出用于内部迭代的原型。“数字孪生”于我而言，给我的感觉是“仿真模拟”的新瓶装旧酒，当然彼时同行时新这玩意儿。于是开始学习和使用Unreal引擎这套技术栈，蓝图和C++那一部分算是入了一点门，因为UE的自带体系，学习这一部分的时候倒是有种学方言的感觉（雾。顺带学了一点时髦的games101，当然学完三维变换，做完第二个assignment，到反走样那一章就没继续下去了。 本来作为全年任务的数字孪生，7月结束后就算是到达了一个里程碑了，8月份部门组织架构调整，我从中台调到了项目组。8月用React+Taro写了一个简易的地图小程序，虽然路径规划功能还没写完就被另有安排了，但这个过程中倒是把React简单入了个门，俗话说会JavaScript以及useState和useEffect就能干活（大雾。期间对比了一下Vue和React，都是简单使用后的体会，个人而言虽然前者自动挡省事，但还是手动挡给到的及时反馈和满足感更加强烈些。 9月打杂修bug，以及做原型。10月临时接手和支撑一个历史悠久的项目，个人职责是主要作为后端进行CURD。期间也参加了绝大多数的需求评审，给我的感觉是产品的想法永远都是尽善尽美最好十全十美的（笑），以及学习了会上扯皮和简化需求等为自己争取时间和空间的必要性和技巧。在作为整个项目支撑的后端之间，感觉到难的部分在于表设计（因为业务流程相对不难理解，并发和用户量也不大），需要充分理解业务需求和流程，以及有一定的项目经验，设计出的表才会比较符合实际需求以及健壮；同时开发流程和规范也十分重要，整个项目初期有原型、设计方案、任务排期和追踪表、版本管理说明等一系列稳定，但在经历了几轮人员和技术栈更替后就几尽丢光了。期间还差点出岔子，项目在汇报演示的时候我和前端同学还在改代码，但是汇报演示时用的是本地开发环境的数据，差点导致已有的功能都无法交付，索性有备份，直接回滚到最近一次的备份，万事大吉虚惊一场。。 11月接到了一个复杂项目，涵盖了线上商城-仓储-加工-物流-财务-本地便民服务一系列应用模块，当然我在这其中主要的职责是业务逻辑梳理、文档编写、代码原型验证。算是简单跟了一遍此类类似系统的业务逻辑，下游B&#x2F;C端用户执行交易并生成订单，订单流转到仓储系统，然后拣货-出货，接着流转到物流系统，进行车辆与人员的调度，最后收货方收到货物，完成订单，整个过程中的单据和流水保存在财务系统。仓储可以异步进行原材料的采购，也可以异步接受加工模块产出的次级产成品的出入库调度。整个应用基于中台微服务的基建，用到了包括单点登录与鉴权、网关、Kafka消息中心等技术，当然我并没有进行深度参与，也算是遗憾。 12月年底，项目交付的任务逐渐进入尾声，工作的中心又逐渐转向内部GIS平台和技术的优化，主要是功能的扩展这一方面。 1.2 毕设受迟先生与一众db佬的影响，也是CS相关的专业课只深入学习了伯克利的CS61B数据结构的影响，毕业设计打算用Java做一个简单的kv数据库，支持CURD、区间索引和持久化。表使用了手搓的红黑树，参考了之前学习红黑树时自己写的笔记（当然笔记也是参考的算法导论和算法4）；索引也是手搓的B+树，参考的是奶牛书。这一部分其实是暑假论文里就做得差不多的内容，毕设主要把持久化做了一下，用了最简单的Java Serialization的writeObject和readObject那一套，以及一个简单的用来parse命令行用户输入指令的parser。整个业务流程是数据进来先写缓冲区，待缓冲区满或命令行程序退出后将数据落盘，支持命令行的CURD与查看表视图的命令。 因为自己造轮子，所以基本上不怎么需要降重，同时可能做的领域比较独特（相对其他同学做的web管理系统，数据分析和可视化，AI相关），所以答辩完后评了优秀，当然这个数据库本身我认为啥也不是（笑）。当然，作为一个玩具玩玩，还是非常考验编码和设计水平的，做完以后也很有成就感。 1.3 生活实习公司找到后，就在附近自己租了一个单间，起先觉得能睡觉就好，所以就找了一间7平也不到的房间，桌子都没有，用的是折叠床上桌凑合的。但也正是那段时间，自认为是适应最快的时期。转正后又过了一段时间，大概8月这样子，换了一间稍大的单间，有桌子和飘窗，顿时感觉生活明媚了很多（侧面证明了住处对人身心的影响 雾）。然后就是定期打扫卫生，整理房间，大致如此。 前半年周末基本都是留给自己的，下半年开始周末总会有多多少少的邀约，当然我也不太擅长拒绝人，事后觉得自己总是在满足别人的行程，却疏于了自我建设。 2. 人2.1 同事因为裁员，所以23年一整年的基调基本都是在送别。和我同期的实习生只有我留了下来，部门唯一的一位女同事，人也很好，称呼她为yf姐吧——告诉我她在请婚假的当天被hr约谈辞退，让我意识到了确实不该对公司抱有太多期待。令我印象最深刻的是10月过来的一位工大的同学，工位在我旁边。我自认为自己没做什么，相比之下。但她临走时送了我一份离别礼，打开是一支香薰和几包泥土和种子，贺卡上她叫我小师傅，说很高兴认识我，因为我让她的实习生活快乐翻倍。我很感动，我会觉得被需要和记得，同时被大方地告知和传递这份需要和传递时很满足。 2.2 F哥6月份的时候，和母亲公司的CEO一起聚了一餐，期间她介绍我认识了其中一位聚美优品的联合创始人，就称呼他为F哥吧。F哥，以及和他背景经历类似的人，都给我一种素养见识过硬，思维敏捷，同时兴趣和爱好也十分广泛，“会玩”的感觉。因为本身背景的差异，我并没有向他请教太多技术上和细节的问题，更多的是“方向”和“价值”一类的话题。通过彼此的交流，我感受到顶尖的人能够全神贯注地听你说的每一句话每一个词，并且真的试图100%地理解，例子就是每次这类人的反问都会让你感到棘手，你必须对你所谈及的话题中的内容的每个细节都了如指掌，才能cover和handle这类反问，他们在视图填充逻辑链上那一处你视图模糊或无意带过的关键帧。而“会玩”，更多地是给我一种这样的人对某一类事物有自己的品味、标准以及支撑这一切的动机和信念。最后，我还记得他的结论——尽早找到自己正反馈的来源。 2.3 室友W8月份换了新的单间后认识了新的室友，就称呼她为W同学吧。她和我一样也是23届毕业生，那之后我和她会分享吃喝、生病了我会把自己开过的药拿出来询问是否能用得上，etc。当然她也会分享自己的吃的喝的，当然，每次都是精准地在我提供了一些什么东西的时候。我在想是不是我的这种分享会给人一种无形的压力呢，如果W同学的信条是有来必有往的话。 某个休息日，碰巧我母亲给我寄了她去潮汕游玩后带回来的当地特色牛肉丸和牛筋丸，又叠加W同学生病。于是我做芹菜白萝卜丸子汤的时候多做了一点，分了W同学一些；后面我甲流的时候没力气下楼，她说做了玉米排骨汤面，让我也分一点。后来，她说年前可能就回南京了，下家找好了，年后入职。 3. 情感12月的最后一天在深圳见了大学同学兼好友，上一次单独见面是21年了，就称呼她为一同学吧。前一天晚上吃饭，她和我分享自己的各位搭子，后来我想我是什么搭子呢，不过答案如果知道了可能反而会没意思吧，我始终觉得人和人之间的关系，如果彼此能产生联系，至少我应该抱着“亲历”和“共进”的态度去面对和相处。我想人面对陌生环境总是要有一个融入的过程的，就像我满怀希望地来到一个地方，却发现位子都已坐满了人，那我要么悻悻地回去，要么焦急地询问和踌躇地盼望是否还会有人离开，是否还会有新的座位。人在一个环境中，其实也是一个“找位置”的过程。一同学和我说了很多在陌生的城市见到故人、在新的学校求学的感受，彼时我还没太多感受，或许是我没有一个像现在一样的时间去沉淀自己思绪的机会。 后来，她看到深圳当代艺术与城市规划馆里的那句“来了就是深圳人”很兴奋。晚饭的时候，一同学和我分享她的室友来深圳的那一天，我便即兴唱了Eason的《好久不见》，她沉默、然后流眼泪（后来一同学补充是自己说到动情处流眼泪的），我不知道该做啥，大概是凭借着习惯吧，我没说啥，只是起身拿纸，顺便留意一同学桌上用完的纸巾，多了的话要扔掉。 希望她也能找到自己的归属，心之所向，素履以往。 情感这种东西，我越是现在越觉得“会表达”的重要性，如果传递不到，那便只能是自我感动，所以我现在很多时候都不试图故意压抑自己了，开心、中意、留恋、以及自以为是的捧哏和搞怪，我都会直接表达和展示出来，当然可能生气和不满我还是会有所选择地保留。 今天我和我妈说，人还是要有个性和自我一点，不要围着另一个人转。 4. 反思与目标4.1 工作的目的和态度最开始，我对于工作的态度是二十分认真，因为我想借由工作上的成果证明自己，那些我写的代码，出自我手的工程，就像是我的孩子，是我一手带大的。 再后来，经历了几次argue之后，我发现工作的出发点是“问题导向”的，而其核心要点在于“目标导向”。这一整套链路不短，个人所处的位置可能和个人的愿景并不匹配。有些人定义什么算“问题”，有些人制定问题的“解”，有些人调度资源并执行“解”，而这一整个过程本身也是递归的。或许我想着我所定义的“问题”，我所制定的“解”，但到我手上的只是作为“执行”的那部分工作，并且为了解决不由你定义的“问题”和“解”，还需要你做出妥协。这一过程是痛苦的，尤其是当你投入五十分热情，三十分认真，二十分执行的时候，结果不一定有十分的评价。某种程度上这和“感情”模块中提到的一样： “如果传递不到，那便只能是自我感动” 正好公司裁员的一些民间消息传过来后，我就觉得，确实人不该对自己能够依靠但又没经过太多检验的东西保有太高的期望，大家相互索取和付出，谁也不亏欠谁是最好的，自我感动就是一种内耗。 由此，我得到的第一个教训是，工作时自己做的事情和预期是一方面，是否能够搞清楚工作背后的逻辑以及match leader的期望，以及能够如实且贴切地汇报出来，又是另一方面。关注目标，拉通对其，拿到结果，保证产出，在工作本身没有太多的附加价值时，保证这些就OK了。 4.2 个人的精力规划最近在看《精力管理》，对里面的一个观点颇为认同，大意为过去的基于时间进行个人事项管理的观点认为生活就像一场长跑，但基于精力进行个人事项管理的观点认为，生活其实更应该像一场场的短跑冲刺——区别在于，前者时间跨度长，关注的愿景远，会引导人性中“遇到复杂就拖延”这一弱点；后者通过间歇性地短跑冲刺和体能恢复，能够促成更高的执行率以及更加及时的回馈。 23年一年熬了很多夜，通宵应该也通了几次，我自我评估，自己也是一旦精力处于专注和充沛的区间，就会想着达成某件事，不管实际上外界处于哪个时间端，深夜还是午后。但往往这么做，后面几天就会产生补偿式地注意力涣散和对娱乐的需求，换言之——短跑了，冲刺了，但没好好休息。所以24年的一个目标就是改善自己的精力管理结构，允许短跑冲刺，但要及时补充休息。这一点具体执行的计划和规则后续再明确一下。 以及，锻炼和健身对精力的恢复确实有用，以往会觉得自己上了一天班很累了，应该回去休息；但是往往这个时候去健身房，练完一轮下来以后，感觉诶，仿佛自己就得到了休息。之前不知道哪里看到的观点，出处不可考，只凭记忆，说，当人的大脑向人体发出倦怠、效率下降、注意力不集中的指令时要重视，这个时候大脑的意思是，停止你“手头上”的事——意味着你可以换一件不同的事情做做，此时大脑是可以得到一定程度的休息和放松的。所以健身和锻炼的习惯需要继续保持下去。 4.3 职业规划根据之前走的知乎的咨询，职业以及技术栈上，“大而全”一定需要让位于“专精”的发展。因此24年的目标之一就是让自己专精地去深入一个领域，定的目标是后端，包括数据库、网络、OS、以及各类中间件和框架的原理了解。在此基础上去谋求认可度与成长空间更大的职位以及更高的薪水。 职业规划和技术成长一定不能闭门造车，同行的conference可以多去参加，发挥互联网的力量多找人咨询，之前知乎咨询认识的大V以及交流群的资源用起来，前期认知以及方法论要正确树立。 这里最重要的是，让事情开始做起来，为此可能需要牺牲一些社交的时间，但这是值得的。当纠结的时候，一定回想自己之前说的： 人还是要有个性和自我一点，不要围着另一个人转。 建立自己的价值，追求自己的生活，每个人都是自己的第一负责人，相信真的朋友可以理解你。 最后，如果有前往文明国家的愿景，请在职业规划的计划完成并且已经在执行的过程中时再考虑，国内个人的成长空间还可以再榨一榨，追求自我价值的建立和传递永远是第一位的。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"第一个小型项目的感想","slug":"第一个小型项目的感想","date":"2022-10-13T15:15:15.000Z","updated":"2022-10-13T16:07:12.628Z","comments":true,"path":"2022/10/13/第一个小型项目的感想/","link":"","permalink":"http://example.com/2022/10/13/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%84%9F%E6%83%B3/","excerpt":"","text":"心路历程趁着学校的专业实践2(最终结果是要交一篇论文)，其实本可以拿之前的课程论文交差了事的，但是想了一下，这也是一个不错的机会，可以让回顾并且总结一下过去所学的知识，并且去尝试将其组装成一个小小的成果出来。 大概自己一部分是菜再加上人还是略佛，另一部分也是个人在学习知识时总是倾向于深度优先，一个点卡住就会想疯狂搞懂，再加上还有考研的准备，，所以直到现在，补齐基础的进度也还是停留在CS 61B 21sp的过半这个位置吧。但仔细回顾起来，其实学到的已经不少了：线性表以及其基于数组和引用的实现，各类树形结构(并查集、二叉堆、平衡树)以及其基于引用和数组的实现etc。我认为自己能独立地把这些知识的内容从intuition到相互之间的联系再到代码的实现讲个八九不离十(个别特别变态的内容可能要准备下——说的就是你，红黑树！)。 写过文档码过代码，结合优秀的课程的知识导入结构与体系的建立与梳理，才能让自己去真正地理解并运用所学的内容。 最开始的时候，我想，要不专业实践2做一个数据结构可视化的项目吧。但是考察了一下，如果简单地取考虑这个项目的需求，那只是调用一下类似于graphviz这种的成熟库以及在此基础上封装api，就能做出个大概来；如果想要相对复杂一些的功能，例如把可视化的实现和具体的语言进行独立，自己做一套简单的，支持循环语句，函数定义和递归调用的语言，然后后台解析用户的指令并生成相应的图形，那就需要编译原理的知识了，但显然对于若干个星期的时间来说，不足以完成这一目标。 于是我的第一个想法就陷入了，简单的话太简单，难的话又太难的局面。于是我想着，有没有更好的方案，其所需要的知识是我学过的，但是实现起来又需要自身对所学知识的深入理解以及良好的设计和编码风格才能完成的项目——于是，一个简单的KV存储系统便成为了我的考虑目标。用红黑树来作为表结构，B+树作为索引，并且在前台有简单的调度系统，来管理数据的读写和处理以及内存和磁盘的交互，这样，既实现了知识内容是基于所学范围的，同时实现起来又有一定难度的目标。 结果最后时间所限，实现了表和索引结构，以及在纯内存场景下的，数据读写和存储的调度。还差磁盘和内存的交互以及把调度模块进行独立地抽象和模块化。 心得始终要保持对项目整体的把握感我认为第一点，也是最重要的一点是，要时刻保持对项目整体的“把握感”。这种把握感在于： 你对项目整体的构思和设计是怎样的，它有可能会在不远的未来发生变动么？ 如果会，变动的频繁程度怎么样？ 每次变动涉及到的变化量，你的预估是多少？ 以及对应地，你该如何进行复杂度的管理？ 你当前的工作处于项目整体的什么位置？ 你所开发的内容，是为了满足整体中的哪一部分的需求？ 会涉及到哪些组件&#x2F;模块的依赖？ 以及随着你当前的工作，项目整体的架构是否会发生改变？ 可以看到，这里有两个不同的抽象层需要兼顾——整体以及局部。其所处的位置不同，但又相互影响，处理不好的结果，那就是当项目的量级达到一定程度后，再要维护时发现复杂度爆炸。 除了项目有抽象上的复杂度需要维护，人脑也有自己的复杂度。工作在local和global时，人脑的context是不一样的，当项目整体的规模够大时，每次context switching带来的开销也够咱喝一壶的。 因此，个人认为，解决之道是在项目开发的时候，documenting的工作也需要实时跟进且不能过于马虎。要做到 叙述项目整体的构建以及主要模块的工作、之间的依赖、以及交互的方式； 分层记录开发流程与进度，维护一个进度树。这样工作在local时，记录和维护较低层的进度信息；local工作完成时，返回祖先层更新进度，同时查看接下来的任务以及回溯整体的开发情况； 在发生重构时(例如在开发子模块时发现可以或需要进行全局性的改动)，也是顺着工作树进行调整； 这样，整个开发的流程和工作有一个较为系统的组织，也方便管理，可以弥补项目中后期复杂度增加以及人脑上下文切换带来的巨大开销所造成的复杂性的增加。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"继承的隐患","slug":"继承的隐患","date":"2022-07-22T16:58:44.000Z","updated":"2024-01-02T15:22:03.481Z","comments":true,"path":"2022/07/23/继承的隐患/","link":"","permalink":"http://example.com/2022/07/23/%E7%BB%A7%E6%89%BF%E7%9A%84%E9%9A%90%E6%82%A3/","excerpt":"","text":"简单回顾一下什么是“继承”“继承(inheritance)”是OOP中重要的一个概念，它可以用于代码复用，也可以用于需要提供多态的场合。当我们“提起”继承时，往往用“is-a”的关系来类比，并将其与组合(composition)要求的“has-a”关系来进行对比：比如我们说“汽车”是“载具”，所以“载具”有的一切属性和行为“汽车”也应该具有；同时“汽车”有“轮胎”，不同的汽车可能拥有不同材质、不同数量、不同造价、不同品牌的轮胎。显而易见我们不能倒过来说“汽车有载具”或者是“汽车是轮胎”，那会引发逻辑以及实践的混乱。Java中用extends关键字来表示“继承”， 1public class A extends B &#123;...&#125; 来表示“类A is-a 类B”的关系，并且A将继承B中所有的属性、方法和内嵌的类(但无法访问被private关键字修饰的)。类A可以有自己专属属性、方法，也可以重写B内的方法。 为什么用OOP——为编程提供抽象在谈继承的隐患之前，先说下为什么要使用OOP。OOP是一种建模的思想，它将任意一项活动视为不同的对象(Object)进行一系列通信与交互的结果。每个对象拥有并维护自己内部的状态，并且对外具有一系列行为可以影响自己或者其它对象的状态。 这样做的一个好处就是，对象是一个已经抽象化了的个体——大多数时候我们无需了解对象内部的实现原理，只需要调用对象的方法就可以完成我们的任务，此即“拿来主义”。这样，不同的程序员可以工作在不同的抽象层级：负责基件的程序员工作在一个抽象程度较低的层次，在“机器”这一级别上压榨出更多的性能；负责应用层的程序员则使用开发好的基件模块来搭建应用程序，并将使用情况与遇到的问题反馈给前一层，他们自己本身无需care基件的底层实现；负责具体业务的工作人员则在搭建好的平台中进行相关操作，当然，他们也不用担心自己的应用是怎么使用的。 这一种每一层都封装自己内部的实现细节，对外暴露特定功能的接口，为上层使用者提供抽象的模式，极大地提高了开发效率，节约了很多程序员宝贵的时间。 继承的潜在“隐患”——破坏封装和抽象性一种常见的说法是，在大多数场合下，尤其是需要代码复用的场合，尽量使用“组合”而非“继承”，除非是需要用到多态特性的场合。这其中的理由是，使用“继承”会提高不同模块间的“耦合度”，从而导致代码可维护性的减弱。 这个说法是有道理的，我们先举个例子来说明“封装”是如何提高“耦合度”，进而埋下“隐患”的。 首先是两个非常简单的类，其中VerboseDog类继承Dog类： 1234567891011// 基类 Dogpublic class Dog &#123; public void bark() &#123; System.out.println(&quot;bark&quot;); &#125; public void barkMany(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; bark(); &#125; &#125;&#125; 12345678910// 派生类 VerboseDogpublic class VerboseDog extends Dog &#123; @Override public void barkMany(int n) &#123; System.out.println(&quot;As a dog, I say: &quot;); for (int i = 0; i &lt; n; i++) &#123; bark(); &#125; &#125;&#125; 乍一看，非常简单，不是么？Dog类只有两个方法，所有的功能都只是向控制台输出文本内容；而VerboseDog类也就重写了barkMany方法，在重复输出“bark”前向控制台多打印了一句“As a dog, I say: ”而已，这会有什么问题呢？那请看—— 倘若有一天，维护Dog类的人重构了一遍Dog类，这个程序员抱着“一切循环皆丑陋，世间至善是递归”的信仰，把Dog类写成如下的形式： 12345678910111213// 重构后的 Dog 类public class Dog &#123; public void bark() &#123; barkMany(1); &#125; public void barkMany(int n) &#123; if (n == 0) &#123; return; &#125; System.out.println(&quot;bark&quot;); barkMany(n - 1); &#125;&#125; 重构之后的Dog类仍然保持与重构前相同的功能，从使用者的视角上看，既无增减也无其它改动。尽管其具体实现与原来的已经不相同了。这个时候，如果再调用VerboseDog类的barkMany方法，就会报“StackOverflow”的错误——可是明明改动之前好好的啊。原来，仔细一看就会发现，VerboseDog重载过的barkMany方法，会和未重载的bark方法相互调用对方并且没有退出机制，这一来一去也就栈溢出了。 当然，在这个例子中，问题不难分析，bug也很好改。但这个简单的例子已经让我们看到，使用“继承”会让我们的派生类对基类“依赖度”变高，用专业点的话来说，就是会提高基类和派生类之间的“耦合”，为了修改自己写的派生类的代码，很有可能不得不去把基类的代码全部都读一遍并且分析一遍，当然，这是比较痛苦的。 有关“继承”与“组合”的取舍另外一个例子(会需要一点数据结构的知识，只到线性表这部分就够了)则展示了对“继承”和“组合”的选择与取舍，考虑基于“List”的“Stack”，简化起见，我们 只考虑Stack的push方法怎么实现； List接口规定所有List的实现都必须有“add”方法； List的实现有基于引用的LinkedList和基于数组的ArrayList。 下面我们分三种情况来分别实现这个需求： 使用继承is-a的 12345public class ExtensionStack&lt;T&gt; extends LinkedList&lt;T&gt; &#123; public void push(T item) &#123; this.add(x) // add 方法是父类 LinkedList 中本就有的 &#125;&#125; 使用组合has-a，但类型写死的 123456public class DelegationStack&lt;T&gt; &#123; private LinkedList&lt;T&gt; _items; // 使用 LinkedList 作为组件 public void push &#123; _items.add(x); &#125;&#125; 使用组合has-a，但允许用户在初始化时自定义使用哪种List的 123456789public class StackAdapter&lt;T&gt; &#123; private List&lt;T&gt; _item; // 使用 List 作为组件 public StackAdapter(List&lt;T&gt; item) &#123; _item = item; &#125; public void push &#123; _item.add(x) &#125;&#125; 对于第一种实现，我们默认Stack作为一种特殊的LinkedList，在LinkedList已有的基础上来实现Stack的push方法。显然，这里继承的使用让LinkedList“已有的基础”几乎完全暴露给了我们。我们需要心里门清Stack继承了LinkedList的哪些方法，其中哪些使我们在Stack中可以访问的，哪些是不能访问的，等等。这些都要求我们至少要去读过LinkedList的源码并且知道主要内容和重要细节。 对于二三种而言，我们都可以默认把对应的List当做一个完整的组件，只使用其具有的功能，而不必过于关注它的实现。从抽象的角度而言，后者要更高些。第二第三种具体的区别就是，写死LinkedList类型可以让我们利用一些LinkedList中特有的方法(如果必要)，只提供List层级的抽象的话，可以在调用时提供更多的灵活性，但是能利用到的List的特性是最为基础的那几个。 上面的都只是一些利弊分析，基于“继承”的实现虽然可能会导致开发时因为耦合度变高导致项目的可维护性降低，但是换来的好处就是对多态的支持，比如在java里，我完全可以拿Stack去做Vector的事情(虽然有时候不太提倡，但事实上它的实现允许你这么干)。按理说一个Stack所支持的操作应该是在顶部进行push和pop，但是实际上完全可以做在任意合法位置插入和删除的事情，比如下面代码(已省略非重要环节，例如定义类和导入相关模块之类的)。 1234567Vector&lt;String&gt; s = new Stack&lt;String&gt;();s.add(&quot;Hello&quot;);s.add(&quot;my&quot;);s.add(&quot;World&quot;);s.add(1, &quot;hi&quot;);s.remove(1);System.out.println(s); 在Java中能够编译通过并且运行(openjdk 18)，然后输出以下结果 [Hello, my, World] 所以具体到开发而言，如何取舍就是仁者见仁智者见智的事情了。 BTW，从前面的例子就能得以窥见，java中Stack的实现是我们说的第一种，基于“继承”来实现的，后面我们会贴出openjdk的实现来进行分析；而c++中无论是gcc系、MSVC系、还是clang系，对stl的stack的实现是基于我们后面说的二三两种，基于“组合”来实现的。下面简单贴个源码，只选取了关键部分： 12345678910111213141516171819202122232425// openjdk 对 Stack 的实现// @source https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/Stack.javapublic class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; // 这里extends了Vector，说明Stack是作为Vector的继承来实现的，上面的例子也证明了这一点 public Stack() &#123; &#125; public E push(E item) &#123; addElement(item); return item; &#125; public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; 1234567891011121314151617181920212223242526272829// llvm-clang 对 Stack 的实现，只摘取源文件中对 Stack 的描述// @source https://github.com/llvm/llvm-project/blob/main/libcxx/include/stack// 源文件中这些都是注释，是为了帮助理解和阅读但不是实现本身namespace std&#123;template &lt;class T, class Container = deque&lt;T&gt;&gt;class stack // 没有声明继承&#123;public: typedef Container container_type; // 使用具有默认值可变类型参数 typedef typename container_type::value_type value_type; typedef typename container_type::reference reference; typedef typename container_type::const_reference const_reference; typedef typename container_type::size_type size_type;protected: container_type c; // 这里只是使用了默认为 deque&lt;T&gt; 类型的容器来实现 stackpublic: /* 已省略各种构造函数 */ bool empty() const; size_type size() const; reference top(); const_reference top() const; void push(const value_type&amp; x); void push(value_type&amp;&amp; x); template &lt;class... Args&gt; reference emplace(Args&amp;&amp;... args); // reference in C++17 void pop(); void swap(stack&amp; c) noexcept(is_nothrow_swappable_v&lt;Container&gt;)&#125;;/* 省略一堆我还看不懂的模板和函数 */ 实际上java.util包里的Stack的实现招致过一些批评，还有人指出自己作为面试官，对方在面试时如果使用到java.util里的Stack的话，是作为一个极大的减分项(negative point)来对待的(出处：Java 程序员，别用 Stack？！)。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"理论","slug":"理论","permalink":"http://example.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"OOP","slug":"OOP","permalink":"http://example.com/tags/OOP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"git合并冲突","slug":"git合并冲突","date":"2022-07-10T17:08:40.000Z","updated":"2022-07-10T17:43:56.790Z","comments":true,"path":"2022/07/11/git合并冲突/","link":"","permalink":"http://example.com/2022/07/11/git%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/","excerpt":"","text":"什么是合并冲突(merge conflict)想象你和小王都是同一个开源项目的贡献者，这一天你拉取了远程仓库的最新版本，但是git却报出了一个错误： 自动合并 xxx冲突（内容）：合并冲突于xxx自动合并失败，修正冲突然后提交修正的结果。 你仔细一看，原来是你上一次commit时的“utils.java”的实现被小王重构并且优化了一下，并且小王也将这个“utils.java”给push到了远程仓库。这样，远程仓库的“utils.java”的内容，和你自己本地分支最新commit的“utils.java”的内容出现了不一致。git的merge能自行解决一部分差异，但另一部分相同位置出现的不同实现就无法被git的自动merge解决了，因为这个时候git就不知道，你是想要保留自己的，还是要保留小王的版本，于是就这样git报出了合并冲突的错误。 所谓“**合并冲突(merge conflict)**”，便是git在合并两个分支的时候，出现了对同一处位置的不同内容。大部分时候git都能自动完成merge工作，但一旦出现上述的同一位置的不同内容的情况，git就会“犯难”，它并不知道该保留哪一处分支的内容，此时就会出现“分支冲突”的错误，并把冲突的解决交给用户。 一个简单的实例现在我们来看一个简单的合并冲突的实例。 比如我现在想要布置一个“实现斐波那契数列第n项求解”的任务，我在一开始就初始化了一个git仓库，并且在默认的分支master上给出了代码的基本框架并且提交了一个commit： 新建工作目录，初始化git仓库 123mkdir merge-conflict-demo # 在当前目录新建一个名为“merge-conflict-demo”的目录cd merge-conflict-demo # 进入这个目录git init. # 在这个进入的目录下初始化一个git仓库 给出“求解斐波那契数列第n项”的基本代码框架 1touch fibonacci.cpp # 新建一个cpp源文件用来求解斐波那契数列的第n项 1234567891011121314// 求解斐波那契数列第n项的代码框架#include &lt;iostream&gt;long long fib(int n) &#123; // To be implemented.&#125;int main() &#123; std::cout &lt;&lt; &quot;请输入一个正整数：&quot;; int n; std::cin &gt;&gt; n; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; fib(n) &lt;&lt; std::endl; return 0;&#125; 提交代码 12git add fibonacci.cppgit commit -m &quot;Provide skeleton of Fibonacci series evaluation by cpp&quot; 这样子git的仓库就有包含代码框架的commit了。现在比方说有两个学生小王和小李，他们接到的任务就是函数long long fib(int n)的具体实现。 小王说，这还不简单，我根据定义写个递归就行，于是他： 基于初始commit创建了自己的分支，并且进行了fib的递归实现 1git checkout -b wang-implementation 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 简单测试并通过了样例以后，小王提交了代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation recursively&quot; 小李一开始也是这么想的，但小李发现这么写会产生很多的重复计算，比如计算“fib(n)”的时候，按递归定义计算了“f(n-2)”；但计算“fib(n-1)”的时候按递归定义又要重新把“fib(n-2)”算一遍，会导致更多不必要的开销。深思熟虑以后，小李决定： 基于初始commit创建了自己的分支，并完成了fib的迭代实现 1git checkout -b li-implementation 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 通过了测试并提交了自己的代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation iteratively&quot; 于是我现在首先merge了小王的代码，然后git成功把我的“fibonacci.cpp”更新成了小王的递归版(记得我自己默认的分支最开始就是master)： 当我看完小王的实现后，觉得没毛病，所以我现在想看小李的实现。于是我把小李的实现merge了进来，git就报出了合并冲突的bug： 造成合并冲突的原因在第一部分已经有讲过了，要合并分支的commit和当前分支所记录的commit里存在对同一位置的不同内容，这个时候git会报出合并冲突并把选择权交给用户。反映到这里，就是小王和小李在“fibonacci.cpp”文件的long long fib(int n)这个函数的实现里选择了不同的方式，让git在合并时感到了“为难”。 合并冲突问题的解决还是第二部分的例子——在合并冲突的文件“fibonacci.cpp”中，我们可以看到git为它生成了一些额外的信息： 123456789101112131415long long fib(int n) &#123;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);======= // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li-implementation&#125; 我们对这些信息进行一点解释说明 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 表示当前分支记录的内容，在这里就是因为一开始commit的就是小王的递归版本，所以“&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD”下面保存的就是小王的实现。 ======= 分隔符，用来区分当前分支的内容与merge进来的分支的内容。 &gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名] 从“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”到“&gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名]”之间的内容，表示merge进来的分支所记录的内容，在这里就是小李所实现的基于迭代的fib函数。 要解决分支冲突，我们需要对保留当前还是接受merge的内容进行取舍。因为显然小李的实现更加高效，所以我们选择保留小李的实现，并且删去小王的实现以及git生成的助记符，然后进行add与commit。 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 如图所示，经过上述的步骤后，我们已经成功解决了合并冲突，并且HEAD指针指向master分支，最近的一次commit显示我们把小李的分支merge进了master分支。 综上所述，进行分支冲突修复的办法就是： 找到发生冲突的文件以及冲突产生的具体位置 选择需要保留的版本，并删去不需要的内容和额外生成的信息 重新add那些发生冲突的文件，然后commit 后记看到这里，我想有些细心的小伙伴可能会问，还记得最开始有一步——先merge小王的递归版本进master么，喏，你看： 一开始的fib函数 123long long fib(int n) &#123; // To be implemented.&#125; merge进来的小王的fib函数 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 那不是也符合我们之前说的“同一位置的不同内容”，那为什么这个没有造成git的合并冲突呢？那这里我们说，这是因为git的合并冲突是牢牢基于“分支”这个结构的，也就是说，不同的分支要存在并行的关系，才有可能出现“分支冲突”。 我们说小王和小李的代码，逻辑上是呈“并行”结构的——他们都是基于最开始的框架代码所在的master分支checkout出来的，所以合并起来会产生冲突。但也正是这个 基于最开始的框架代码所在的master分支checkout出来的 这个条件，使得小王的递归代码在一开始和master进行merge的时候，它们二者呈现的是一个先后的“顺序”关系而不是一种并行的关系，所以git认为——这是你用新版本去覆盖老版本啊，完全没有问题。所以这样一种先后的串行关系并不会造成“合并冲突”，只有“并行”的分支关系才有可能造成合并冲突。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"第一篇Blog","slug":"第一篇Blog","date":"2022-07-06T15:15:33.000Z","updated":"2022-07-06T16:03:00.573Z","comments":true,"path":"2022/07/06/第一篇Blog/","link":"","permalink":"http://example.com/2022/07/06/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/","excerpt":"","text":"一个并不很介绍的自我介绍 “观看这些使用禄莱相机和樱花牌胶片记录下的彩色影像，随着这些灿烂明亮的颜色，我们似乎对于那个年代的记忆和遐想也鲜活起来。这些照片变成了当下的我们与旧日世界沟通的桥梁。照片中的一切都在不断地重复，照片与照片之间也在不断地交互勾连。秋山亮二让我们看到了一个永远停留在照片上的、上世纪80年代的中国，一个当下社会的“童年”。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。我们也许会惊讶地发现，没有什么会彻底消失，任何消失的东西都会留下痕迹。 秋山亮二让我们看到了一个永远停留在照片上的80年代的中国，一个当下社会的“童年”。而只有通过我们的凝视和思考，这个被封存在影像中的80年代，才能再一次于我们的脑海中浮现。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。 昨日的世界依然以一种隐秘而有力的方式影响着我们的当下。怀旧从来都不仅仅是关于过去，更是关乎我们对当下和未来的理解。” 今年4月清明假期的时候，一时兴起就自己一人到了良渚。上面这段话应该是第二天的行程，拜访良渚文化艺术中心的时候看到的。那时举办的展览叫“你好，小朋友”，印象深刻——虽然提起80年代的共和国，人们应该会有很多好与不好的回忆，但照片里展示出的，小朋友的神采也好，背景里的市容市貌也好，无不呈现出一派生机勃勃的景象。 当然，无论旁人如何论说，回过头去看那一段历史，我想没有人可以否定80年代是一个新旧交替，充满朝气的年代，共和国也好，共和国土地上的人也好，他们都将翻开历史崭新的一页，并走向更加宽阔的舞台，并且迎接属于自己的机遇与挑战。 或许有人会反驳，你这说的滤镜也开得太厉害了，我所认识的80年代根本就不是这个样子，当时我跟你说…… 没错，反驳有理。但这也是我正想说的——记录的重要性。押井守导演的1995版的攻壳机动队有一幕，被Ghost导入虚假记忆的嫌疑犯，在得知自己关于妻子和女儿所有的记忆都是虚构的真相后，也就崩溃了。 “世界上本没有路，走的人多了，也便成了路”，我们从哪里来——取决于我们走过的路；“认识你自己”，我们是谁——取决于我们的经历的记忆。 所以，去记录，便是对围绕“自我”展开的所有议题的尝试解答；去分享，则是探知世界，并寻求一个连接的入口，来导向更多可能性的过程。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"}]}],"categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"理论","slug":"理论","permalink":"http://example.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"OOP","slug":"OOP","permalink":"http://example.com/tags/OOP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]}