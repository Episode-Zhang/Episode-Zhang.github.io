{"meta":{"title":"Episode Zhang's Blog","subtitle":"世界之底的某处自留地","description":"记录想记录的一切","author":"Episode Zhang","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2022-07-06T16:22:26.000Z","updated":"2022-07-06T16:26:25.526Z","comments":true,"path":"aboutme/index.html","permalink":"http://example.com/aboutme/index.html","excerpt":"","text":"👋 先打个招呼吧，你好！ 👉 放在前面，关于为什么想写博客：第一篇Blog 😉 更多基本信息： 00年出生于东南沿海地区; 现役某财经高校大学生; 边缘交叉专业; 喜欢写代码，会觉得实现自己的想法很有意思; 😶 我的价值观：文明、理性、实事求是"},{"title":"tag","date":"2022-07-06T12:54:52.000Z","updated":"2022-07-06T16:31:08.209Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"git合并冲突","slug":"git合并冲突","date":"2022-07-10T17:08:40.000Z","updated":"2022-07-10T17:37:48.379Z","comments":true,"path":"2022/07/11/git合并冲突/","link":"","permalink":"http://example.com/2022/07/11/git%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/","excerpt":"","text":"git合并冲突什么是合并冲突(merge conflict)想象你和小王都是同一个开源项目的贡献者，这一天你拉取了远程仓库的最新版本，但是git却报出了一个错误： 自动合并 xxx冲突（内容）：合并冲突于xxx自动合并失败，修正冲突然后提交修正的结果。 你仔细一看，原来是你上一次commit时的“utils.java”的实现被小王重构并且优化了一下，并且小王也将这个“utils.java”给push到了远程仓库。这样，远程仓库的“utils.java”的内容，和你自己本地分支最新commit的“utils.java”的内容出现了不一致。git的merge能自行解决一部分差异，但另一部分相同位置出现的不同实现就无法被git的自动merge解决了，因为这个时候git就不知道，你是想要保留自己的，还是要保留小王的版本，于是就这样git报出了合并冲突的错误。 所谓“**合并冲突(merge conflict)**”，便是git在合并两个分支的时候，出现了对同一处位置的不同内容。大部分时候git都能自动完成merge工作，但一旦出现上述的同一位置的不同内容的情况，git就会“犯难”，它并不知道该保留哪一处分支的内容，此时就会出现“分支冲突”的错误，并把冲突的解决交给用户。 一个简单的实例现在我们来看一个简单的合并冲突的实例。 比如我现在想要布置一个“实现斐波那契数列第n项求解”的任务，我在一开始就初始化了一个git仓库，并且在默认的分支master上给出了代码的基本框架并且提交了一个commit： 新建工作目录，初始化git仓库 123mkdir merge-conflict-demo # 在当前目录新建一个名为“merge-conflict-demo”的目录cd merge-conflict-demo # 进入这个目录git init. # 在这个进入的目录下初始化一个git仓库 给出“求解斐波那契数列第n项”的基本代码框架 1touch fibonacci.cpp # 新建一个cpp源文件用来求解斐波那契数列的第n项 1234567891011121314// 求解斐波那契数列第n项的代码框架#include &lt;iostream&gt;long long fib(int n) &#123; // To be implemented.&#125;int main() &#123; std::cout &lt;&lt; &quot;请输入一个正整数：&quot;; int n; std::cin &gt;&gt; n; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; fib(n) &lt;&lt; std::endl; return 0;&#125; 提交代码 12git add fibonacci.cppgit commit -m &quot;Provide skeleton of Fibonacci series evaluation by cpp&quot; 这样子git的仓库就有包含代码框架的commit了。现在比方说有两个学生小王和小李，他们接到的任务就是函数long long fib(int n)的具体实现。 小王说，这还不简单，我根据定义写个递归就行，于是他： 基于初始commit创建了自己的分支，并且进行了fib的递归实现 1git checkout -b wang-implementation 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 简单测试并通过了样例以后，小王提交了代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation recursively&quot; 小李一开始也是这么想的，但小李发现这么写会产生很多的重复计算，比如计算“fib(n)”的时候，按递归定义计算了“f(n-2)”；但计算“fib(n-1)”的时候按递归定义又要重新把“fib(n-2)”算一遍，会导致更多不必要的开销。深思熟虑以后，小李决定： 基于初始commit创建了自己的分支，并完成了fib的迭代实现 1git checkout -b li-implementation 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 通过了测试并提交了自己的代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation iteratively&quot; 于是我现在首先merge了小王的代码，然后git成功把我的“fibonacci.cpp”更新成了小王的递归版(记得我自己默认的分支最开始就是master)： 当我看完小王的实现后，觉得没毛病，所以我现在想看小李的实现。于是我把小李的实现merge了进来，git就报出了合并冲突的bug： 造成合并冲突的原因在第一部分已经有讲过了，要合并分支的commit和当前分支所记录的commit里存在对同一位置的不同内容，这个时候git会报出合并冲突并把选择权交给用户。反映到这里，就是小王和小李在“fibonacci.cpp”文件的long long fib(int n)这个函数的实现里选择了不同的方式，让git在合并时感到了“为难”。 合并冲突问题的解决还是第二部分的例子——在合并冲突的文件“fibonacci.cpp”中，我们可以看到git为它生成了一些额外的信息： 123456789101112131415long long fib(int n) &#123;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);======= // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li-implementation&#125; 我们对这些信息进行一点解释说明 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 表示当前分支记录的内容，在这里就是因为一开始commit的就是小王的递归版本，所以“&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD”下面保存的就是小王的实现。 ======= 分隔符，用来区分当前分支的内容与merge进来的分支的内容。 &gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名] 从“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”到“&gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名]”之间的内容，表示merge进来的分支所记录的内容，在这里就是小李所实现的基于迭代的fib函数。 要解决分支冲突，我们需要对保留当前还是接受merge的内容进行取舍。因为显然小李的实现更加高效，所以我们选择保留小李的实现，并且删去小王的实现以及git生成的助记符，然后进行add与commit。 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 如图所示，经过上述的步骤后，我们已经成功解决了合并冲突，并且HEAD指针指向master分支，最近的一次commit显示我们把小李的分支merge进了master分支。 综上所述，进行分支冲突修复的办法就是： 找到发生冲突的文件以及冲突产生的具体位置 选择需要保留的版本，并删去不需要的内容和额外生成的信息 重新add那些发生冲突的文件，然后commit 后记看到这里，我想有些细心的小伙伴可能会问，还记得最开始有一步——先merge小王的递归版本进master么，喏，你看： 一开始的fib函数 123long long fib(int n) &#123; // To be implemented.&#125; merge进来的小王的fib函数 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 那不是也符合我们之前说的“同一位置的不同内容”，那为什么这个没有造成git的合并冲突呢？那这里我们说，这是因为git的合并冲突是牢牢基于“分支”这个结构的，也就是说，不同的分支要存在并行的关系，才有可能出现“分支冲突”。 我们说小王和小李的代码，逻辑上是呈“并行”结构的——他们都是基于最开始的框架代码所在的master分支checkout出来的，所以合并起来会产生冲突。但也正是这个 基于最开始的框架代码所在的master分支checkout出来的 这个条件，使得小王的递归代码在一开始和master进行merge的时候，它们二者呈现的是一个先后的“顺序”关系而不是一种并行的关系，所以git认为——这是你用新版本去覆盖老版本啊，完全没有问题。所以这样一种先后的串行关系并不会造成“合并冲突”，只有“并行”的分支关系才有可能造成合并冲突。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"第一篇Blog","slug":"第一篇Blog","date":"2022-07-06T15:15:33.000Z","updated":"2022-07-06T16:03:00.573Z","comments":true,"path":"2022/07/06/第一篇Blog/","link":"","permalink":"http://example.com/2022/07/06/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/","excerpt":"","text":"一个并不很介绍的自我介绍 “观看这些使用禄莱相机和樱花牌胶片记录下的彩色影像，随着这些灿烂明亮的颜色，我们似乎对于那个年代的记忆和遐想也鲜活起来。这些照片变成了当下的我们与旧日世界沟通的桥梁。照片中的一切都在不断地重复，照片与照片之间也在不断地交互勾连。秋山亮二让我们看到了一个永远停留在照片上的、上世纪80年代的中国，一个当下社会的“童年”。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。我们也许会惊讶地发现，没有什么会彻底消失，任何消失的东西都会留下痕迹。 秋山亮二让我们看到了一个永远停留在照片上的80年代的中国，一个当下社会的“童年”。而只有通过我们的凝视和思考，这个被封存在影像中的80年代，才能再一次于我们的脑海中浮现。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。 昨日的世界依然以一种隐秘而有力的方式影响着我们的当下。怀旧从来都不仅仅是关于过去，更是关乎我们对当下和未来的理解。” 今年4月清明假期的时候，一时兴起就自己一人到了良渚。上面这段话应该是第二天的行程，拜访良渚文化艺术中心的时候看到的。那时举办的展览叫“你好，小朋友”，印象深刻——虽然提起80年代的共和国，人们应该会有很多好与不好的回忆，但照片里展示出的，小朋友的神采也好，背景里的市容市貌也好，无不呈现出一派生机勃勃的景象。 当然，无论旁人如何论说，回过头去看那一段历史，我想没有人可以否定80年代是一个新旧交替，充满朝气的年代，共和国也好，共和国土地上的人也好，他们都将翻开历史崭新的一页，并走向更加宽阔的舞台，并且迎接属于自己的机遇与挑战。 或许有人会反驳，你这说的滤镜也开得太厉害了，我所认识的80年代根本就不是这个样子，当时我跟你说…… 没错，反驳有理。但这也是我正想说的——记录的重要性。押井守导演的1995版的攻壳机动队有一幕，被Ghost导入虚假记忆的嫌疑犯，在得知自己关于妻子和女儿所有的记忆都是虚构的真相后，也就崩溃了。 “世界上本没有路，走的人多了，也便成了路”，我们从哪里来——取决于我们走过的路；“认识你自己”，我们是谁——取决于我们的经历的记忆。 所以，去记录，便是对围绕“自我”展开的所有议题的尝试解答；去分享，则是探知世界，并寻求一个连接的入口，来导向更多可能性的过程。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"}]}],"categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"}]}