{"meta":{"title":"Episode Zhang's Blog","subtitle":"世界之底的某处自留地","description":"记录想记录的一切","author":"Episode Zhang","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2022-07-06T16:22:26.000Z","updated":"2022-10-13T16:17:50.556Z","comments":true,"path":"aboutme/index.html","permalink":"http://example.com/aboutme/index.html","excerpt":"","text":"👋 先打个招呼吧，你好！很高兴你能阅读我的博客~ 👉 放在前面，关于为什么想写博客：第一篇Blog 😉 更多基本信息： 00年，生于东南沿海; 生理性别为顺性别男性，期望并正在实践着去成为一个包容的人; 财经院校的本科生; 交叉专业，努力提升开发能力ing; 喜欢写代码，会觉得实现自己的想法很有意思; 😇 我的价值观：尊重、包容、理性、文明、自由."},{"title":"tag","date":"2022-07-06T12:54:52.000Z","updated":"2022-07-06T16:31:08.209Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"第一个小型项目的感想","slug":"第一个小型项目的感想","date":"2022-10-13T15:15:15.000Z","updated":"2022-10-13T16:07:12.628Z","comments":true,"path":"2022/10/13/第一个小型项目的感想/","link":"","permalink":"http://example.com/2022/10/13/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%84%9F%E6%83%B3/","excerpt":"","text":"心路历程趁着学校的专业实践2(最终结果是要交一篇论文)，其实本可以拿之前的课程论文交差了事的，但是想了一下，这也是一个不错的机会，可以让回顾并且总结一下过去所学的知识，并且去尝试将其组装成一个小小的成果出来。 大概自己一部分是菜再加上人还是略佛，另一部分也是个人在学习知识时总是倾向于深度优先，一个点卡住就会想疯狂搞懂，再加上还有考研的准备，，所以直到现在，补齐基础的进度也还是停留在CS 61B 21sp的过半这个位置吧。但仔细回顾起来，其实学到的已经不少了：线性表以及其基于数组和引用的实现，各类树形结构(并查集、二叉堆、平衡树)以及其基于引用和数组的实现etc。我认为自己能独立地把这些知识的内容从intuition到相互之间的联系再到代码的实现讲个八九不离十(个别特别变态的内容可能要准备下——说的就是你，红黑树！)。 写过文档码过代码，结合优秀的课程的知识导入结构与体系的建立与梳理，才能让自己去真正地理解并运用所学的内容。 最开始的时候，我想，要不专业实践2做一个数据结构可视化的项目吧。但是考察了一下，如果简单地取考虑这个项目的需求，那只是调用一下类似于graphviz这种的成熟库以及在此基础上封装api，就能做出个大概来；如果想要相对复杂一些的功能，例如把可视化的实现和具体的语言进行独立，自己做一套简单的，支持循环语句，函数定义和递归调用的语言，然后后台解析用户的指令并生成相应的图形，那就需要编译原理的知识了，但显然对于若干个星期的时间来说，不足以完成这一目标。 于是我的第一个想法就陷入了，简单的话太简单，难的话又太难的局面。于是我想着，有没有更好的方案，其所需要的知识是我学过的，但是实现起来又需要自身对所学知识的深入理解以及良好的设计和编码风格才能完成的项目——于是，一个简单的KV存储系统便成为了我的考虑目标。用红黑树来作为表结构，B+树作为索引，并且在前台有简单的调度系统，来管理数据的读写和处理以及内存和磁盘的交互，这样，既实现了知识内容是基于所学范围的，同时实现起来又有一定难度的目标。 结果最后时间所限，实现了表和索引结构，以及在纯内存场景下的，数据读写和存储的调度。还差磁盘和内存的交互以及把调度模块进行独立地抽象和模块化。 心得始终要保持对项目整体的把握感我认为第一点，也是最重要的一点是，要时刻保持对项目整体的“把握感”。这种把握感在于： 你对项目整体的构思和设计是怎样的，它有可能会在不远的未来发生变动么？ 如果会，变动的频繁程度怎么样？ 每次变动涉及到的变化量，你的预估是多少？ 以及对应地，你该如何进行复杂度的管理？ 你当前的工作处于项目整体的什么位置？ 你所开发的内容，是为了满足整体中的哪一部分的需求？ 会涉及到哪些组件&#x2F;模块的依赖？ 以及随着你当前的工作，项目整体的架构是否会发生改变？ 可以看到，这里有两个不同的抽象层需要兼顾——整体以及局部。其所处的位置不同，但又相互影响，处理不好的结果，那就是当项目的量级达到一定程度后，再要维护时发现复杂度爆炸。 除了项目有抽象上的复杂度需要维护，人脑也有自己的复杂度。工作在local和global时，人脑的context是不一样的，当项目整体的规模够大时，每次context switching带来的开销也够咱喝一壶的。 因此，个人认为，解决之道是在项目开发的时候，documenting的工作也需要实时跟进且不能过于马虎。要做到 叙述项目整体的构建以及主要模块的工作、之间的依赖、以及交互的方式； 分层记录开发流程与进度，维护一个进度树。这样工作在local时，记录和维护较低层的进度信息；local工作完成时，返回祖先层更新进度，同时查看接下来的任务以及回溯整体的开发情况； 在发生重构时(例如在开发子模块时发现可以或需要进行全局性的改动)，也是顺着工作树进行调整； 这样，整个开发的流程和工作有一个较为系统的组织，也方便管理，可以弥补项目中后期复杂度增加以及人脑上下文切换带来的巨大开销所造成的复杂性的增加。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"继承的隐患","slug":"继承的隐患","date":"2022-07-22T16:58:44.000Z","updated":"2022-07-23T09:20:05.185Z","comments":true,"path":"2022/07/23/继承的隐患/","link":"","permalink":"http://example.com/2022/07/23/%E7%BB%A7%E6%89%BF%E7%9A%84%E9%9A%90%E6%82%A3/","excerpt":"","text":"简单回顾一下什么是“继承”“继承(inheritance)”是OOP中重要的一个概念，它可以用于代码复用，也可以用于需要提供多态的场合。当我们“提起”继承时，往往用“is-a”的关系来类比，并将其与组合(composition)要求的“has-a”关系来进行对比：比如我们说“汽车”是“载具”，所以“载具”有的一切属性和行为“汽车”也应该具有；同时“汽车”有“轮胎”，不同的汽车可能拥有不同材质、不同数量、不同造价、不同品牌的轮胎。显而易见我们不能倒过来说“汽车有载具”或者是“汽车是轮胎”，那会引发逻辑以及实践的混乱。Java中用extends关键字来表示“继承”， 1public class A extends B &#123;...&#125; 来表示“类A is-a 类B”的关系，并且A将继承B中所有的属性、方法和内嵌的类(但无法访问被private关键字修饰的)。类A可以有自己专属属性、方法，也可以重写B内的方法。 为什么用OOP——为编程提供抽象在谈继承的隐患之前，先说下为什么要使用OOP。OOP是一种建模的思想，它将任意一项活动视为不同的对象(Object)进行一系列通信与交互的结果。每个对象拥有并维护自己内部的状态，并且对外具有一系列行为可以影响自己或者其它对象的状态。 这样做的一个好处就是，对象是一个已经抽象化了的个体——大多数时候我们无需了解对象内部的实现原理，只需要调用对象的方法就可以完成我们的任务，此即“拿来主义”。这样，不同的程序员可以工作在不同的抽象层级：负责基件的程序员工作在一个抽象程度较低的层次，在“机器”这一级别上压榨出更多的性能；负责应用层的程序员则使用开发好的基件模块来搭建应用程序，并将使用情况与遇到的问题反馈给前一层，他们自己本身无需care基件的底层实现；负责具体业务的工作人员则在搭建好的平台中进行相关操作，当然，他们也不用担心自己的应用是怎么使用的。 这一种每一层都封装自己内部的实现细节，对外暴露特定功能的接口，为上层使用者提供抽象的模式，极大地提高了开发效率，节约了很多程序员宝贵的时间。 继承的潜在“隐患”——破坏封装和抽象性一种常见的说法是，在大多数场合下，尤其是需要代码复用的场合，尽量使用“组合”而非“继承”，除非是需要用到多态特性的场合。这其中的理由是，使用“继承”会提高不同模块间的“耦合度”，从而导致代码可维护性的减弱。 这个说法是有道理的，我们先举个例子来说明“封装”是如何提高“耦合度”，进而埋下“隐患”的。 首先是两个非常简单的类，其中VerboseDog类继承Dog类： 1234567891011// 基类 Dogpublic class Dog &#123; public void bark() &#123; System.out.println(&quot;bark&quot;); &#125; public void barkMany(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; bark(); &#125; &#125;&#125; 12345678910// 派生类 VerboseDogpublic class VerboseDog extends Dog &#123; @Override public void barkMany(int n) &#123; System.out.println(&quot;As a dog, I say: &quot;); for (int i = 0; i &lt; n; i++) &#123; bark(); &#125; &#125;&#125; 乍一看，非常简单，不是么？Dog类只有两个方法，所有的功能都只是向控制台输出文本内容；而VerboseDog类也就重写了barkMany方法，在重复输出“bark”前向控制台多打印了一句“As a dog, I say: ”而已，这会有什么问题呢？那请看—— 倘若有一天，维护Dog类的人重构了一遍Dog类，这个程序员抱着“一切循环皆丑陋，世间至善是递归”的信仰，把Dog类写成如下的形式： 12345678910111213// 重构后的 Dog 类public class Dog &#123; public void bark() &#123; barkMany(1); &#125; public void barkMany(int n) &#123; if (n == 0) &#123; return; &#125; System.out.println(&quot;bark&quot;); barkMany(n - 1); &#125;&#125; 重构之后的Dog类仍然保持与重构前相同的功能，从使用者的视角上看，既无增减也无其它改动。尽管其具体实现与原来的已经不相同了。这个时候，如果再调用VerboseDog类的barkMany方法，就会报“StackOverflow”的错误——可是明明改动之前好好的啊。原来，仔细一看就会发现，VerboseDog重载过的barkMany方法，会和未重载的bark方法相互调用对方并且没有退出机制，这一来一去也就栈溢出了。 当然，在这个例子中，问题不难分析，bug也很好改。但这个简单的例子已经让我们看到，使用“继承”会让我们的派生类对基类“依赖度”变高，用专业点的话来说，就是会提高基类和派生类之间的“耦合”，为了修改自己写的派生类的代码，很有可能不得不去把基类的代码全部都读一遍并且分析一遍，当然，这是比较痛苦的。 有关“继承”与“组合”的取舍另外一个例子(会需要一点数据结构的知识，只到线性表这部分就够了)则展示了对“继承”和“组合”的选择与取舍，考虑基于“List”的“Stack”，简化起见，我们 只考虑Stack的push方法怎么实现； List接口规定所有List的实现都必须有“add”方法； List的实现有基于引用的LinkedList和基于数组的ArrayList。 下面我们分三种情况来分别实现这个需求： 使用继承is-a的 12345public class ExtensionStack&lt;T&gt; extends LinkedList&lt;T&gt; &#123; public void push(T item) &#123; this.add(x) // add 方法是父类 LinkedList 中本就有的 &#125;&#125; 使用组合has-a，但类型写死的 123456public class DelegationStack&lt;T&gt; &#123; private LinkedList&lt;T&gt; _items; // 使用 LinkedList 作为组件 public void push &#123; _items.add(x); &#125;&#125; 使用组合has-a，但允许用户在初始化时自定义使用哪种List的 123456789public class StackAdapter&lt;T&gt; &#123; private List&lt;T&gt; _item; // 使用 List 作为组件 public StackAdapter(List&lt;T&gt; item) &#123; _item = item; &#125; public void push &#123; _item.add(x) &#125;&#125; 对于第一种实现，我们默认Stack作为一种特殊的LinkedList，在LinkedList已有的基础上来实现Stack的push方法。显然，这里继承的使用让LinkedList“已有的基础”几乎完全暴露给了我们。我们需要心里门清Stack继承了LinkedList的哪些方法，其中哪些使我们在Stack中可以访问的，哪些是不能访问的，等等。这些都要求我们至少要去读过LinkedList的源码并且知道主要内容和重要细节。 对于二三种而言，我们都可以默认把对应的List当做一个完整的组件，只使用其具有的功能，而不必过于关注它的实现。从抽象的角度而言，后者要更高些。第二第三种具体的区别就是，写死LinkedList类型可以让我们利用一些LinkedList中特有的方法(如果必要)，只提供List层级的抽象的话，可以在调用时提供更多的灵活性，但是能利用到的List的特性是最为基础的那几个。 上面的都只是一些利弊分析，基于“继承”的实现虽然可能会导致开发时因为耦合度变高导致项目的可维护性降低，但是换来的好处就是对多态的支持，比如在java里，我完全可以拿Stack去做Vector的事情(虽然有时候不太提倡，但事实上它的实现允许你这么干)。按理说一个Stack所支持的操作应该是在顶部进行push和pop，但是实际上完全可以做在任意合法位置插入和删除的事情，比如下面代码(已省略非重要环节，例如定义类和导入相关模块之类的)。 1234567Vector&lt;String&gt; s = new Stack&lt;String&gt;();s.add(&quot;Hello&quot;);s.add(&quot;my&quot;);s.add(&quot;World&quot;);s.add(1, &quot;hi&quot;);s.remove(1);System.out.println(s); 在Java中能够编译通过并且运行(openjdk 18)，然后输出以下结果 [Hello, my, World] 所以具体到开发而言，如何取舍就是仁者见仁智者见智的事情了。 BTW，从前面的例子就能得以窥见，java中Stack的实现是我们说的第一种，基于“继承”来实现的，后面我们会贴出openjdk的实现来进行分析；而c++中无论是gcc系、MSVC系、还是clang系，对stl的stack的实现是基于我们后面说的二三两种，基于“组合”来实现的。下面简单贴个源码，只选取了关键部分： 12345678910111213141516171819202122232425// openjdk 对 Stack 的实现// @source https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/Stack.javapublic class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; // 这里extends了Vector，说明Stack是作为Vector的继承来实现的，上面的例子也证明了这一点 public Stack() &#123; &#125; public E push(E item) &#123; addElement(item); return item; &#125; public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; 1234567891011121314151617181920212223242526272829// llvm-clang 对 Stack 的实现，只摘取源文件中对 Stack 的描述// @source https://github.com/llvm/llvm-project/blob/main/libcxx/include/stack// 源文件中这些都是注释，是为了帮助理解和阅读但不是实现本身namespace std&#123;template &lt;class T, class Container = deque&lt;T&gt;&gt;class stack // 没有声明继承&#123;public: typedef Container container_type; // 使用具有默认值可变类型参数 typedef typename container_type::value_type value_type; typedef typename container_type::reference reference; typedef typename container_type::const_reference const_reference; typedef typename container_type::size_type size_type;protected: container_type c; // 这里只是使用了默认为 deque&lt;T&gt; 类型的容器来实现 stackpublic: /* 已省略各种构造函数 */ bool empty() const; size_type size() const; reference top(); const_reference top() const; void push(const value_type&amp; x); void push(value_type&amp;&amp; x); template &lt;class... Args&gt; reference emplace(Args&amp;&amp;... args); // reference in C++17 void pop(); void swap(stack&amp; c) noexcept(is_nothrow_swappable_v&lt;Container&gt;)&#125;;/* 省略一堆我还看不懂的模板和函数 */ 实际上java.util包里的Stack的实现招致过一些批评，还有人指出自己作为面试官，对方在面试时如果使用到java.util里的Stack的话，是作为一个极大的减分项(negative point)来对待的(出处：Java 程序员，别用 Stack？！)。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"理论","slug":"理论","permalink":"http://example.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"OOP","slug":"OOP","permalink":"http://example.com/tags/OOP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"git合并冲突","slug":"git合并冲突","date":"2022-07-10T17:08:40.000Z","updated":"2022-07-10T17:43:56.790Z","comments":true,"path":"2022/07/11/git合并冲突/","link":"","permalink":"http://example.com/2022/07/11/git%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/","excerpt":"","text":"什么是合并冲突(merge conflict)想象你和小王都是同一个开源项目的贡献者，这一天你拉取了远程仓库的最新版本，但是git却报出了一个错误： 自动合并 xxx冲突（内容）：合并冲突于xxx自动合并失败，修正冲突然后提交修正的结果。 你仔细一看，原来是你上一次commit时的“utils.java”的实现被小王重构并且优化了一下，并且小王也将这个“utils.java”给push到了远程仓库。这样，远程仓库的“utils.java”的内容，和你自己本地分支最新commit的“utils.java”的内容出现了不一致。git的merge能自行解决一部分差异，但另一部分相同位置出现的不同实现就无法被git的自动merge解决了，因为这个时候git就不知道，你是想要保留自己的，还是要保留小王的版本，于是就这样git报出了合并冲突的错误。 所谓“**合并冲突(merge conflict)**”，便是git在合并两个分支的时候，出现了对同一处位置的不同内容。大部分时候git都能自动完成merge工作，但一旦出现上述的同一位置的不同内容的情况，git就会“犯难”，它并不知道该保留哪一处分支的内容，此时就会出现“分支冲突”的错误，并把冲突的解决交给用户。 一个简单的实例现在我们来看一个简单的合并冲突的实例。 比如我现在想要布置一个“实现斐波那契数列第n项求解”的任务，我在一开始就初始化了一个git仓库，并且在默认的分支master上给出了代码的基本框架并且提交了一个commit： 新建工作目录，初始化git仓库 123mkdir merge-conflict-demo # 在当前目录新建一个名为“merge-conflict-demo”的目录cd merge-conflict-demo # 进入这个目录git init. # 在这个进入的目录下初始化一个git仓库 给出“求解斐波那契数列第n项”的基本代码框架 1touch fibonacci.cpp # 新建一个cpp源文件用来求解斐波那契数列的第n项 1234567891011121314// 求解斐波那契数列第n项的代码框架#include &lt;iostream&gt;long long fib(int n) &#123; // To be implemented.&#125;int main() &#123; std::cout &lt;&lt; &quot;请输入一个正整数：&quot;; int n; std::cin &gt;&gt; n; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; fib(n) &lt;&lt; std::endl; return 0;&#125; 提交代码 12git add fibonacci.cppgit commit -m &quot;Provide skeleton of Fibonacci series evaluation by cpp&quot; 这样子git的仓库就有包含代码框架的commit了。现在比方说有两个学生小王和小李，他们接到的任务就是函数long long fib(int n)的具体实现。 小王说，这还不简单，我根据定义写个递归就行，于是他： 基于初始commit创建了自己的分支，并且进行了fib的递归实现 1git checkout -b wang-implementation 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 简单测试并通过了样例以后，小王提交了代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation recursively&quot; 小李一开始也是这么想的，但小李发现这么写会产生很多的重复计算，比如计算“fib(n)”的时候，按递归定义计算了“f(n-2)”；但计算“fib(n-1)”的时候按递归定义又要重新把“fib(n-2)”算一遍，会导致更多不必要的开销。深思熟虑以后，小李决定： 基于初始commit创建了自己的分支，并完成了fib的迭代实现 1git checkout -b li-implementation 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 通过了测试并提交了自己的代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation iteratively&quot; 于是我现在首先merge了小王的代码，然后git成功把我的“fibonacci.cpp”更新成了小王的递归版(记得我自己默认的分支最开始就是master)： 当我看完小王的实现后，觉得没毛病，所以我现在想看小李的实现。于是我把小李的实现merge了进来，git就报出了合并冲突的bug： 造成合并冲突的原因在第一部分已经有讲过了，要合并分支的commit和当前分支所记录的commit里存在对同一位置的不同内容，这个时候git会报出合并冲突并把选择权交给用户。反映到这里，就是小王和小李在“fibonacci.cpp”文件的long long fib(int n)这个函数的实现里选择了不同的方式，让git在合并时感到了“为难”。 合并冲突问题的解决还是第二部分的例子——在合并冲突的文件“fibonacci.cpp”中，我们可以看到git为它生成了一些额外的信息： 123456789101112131415long long fib(int n) &#123;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);======= // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li-implementation&#125; 我们对这些信息进行一点解释说明 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 表示当前分支记录的内容，在这里就是因为一开始commit的就是小王的递归版本，所以“&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD”下面保存的就是小王的实现。 ======= 分隔符，用来区分当前分支的内容与merge进来的分支的内容。 &gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名] 从“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”到“&gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名]”之间的内容，表示merge进来的分支所记录的内容，在这里就是小李所实现的基于迭代的fib函数。 要解决分支冲突，我们需要对保留当前还是接受merge的内容进行取舍。因为显然小李的实现更加高效，所以我们选择保留小李的实现，并且删去小王的实现以及git生成的助记符，然后进行add与commit。 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 如图所示，经过上述的步骤后，我们已经成功解决了合并冲突，并且HEAD指针指向master分支，最近的一次commit显示我们把小李的分支merge进了master分支。 综上所述，进行分支冲突修复的办法就是： 找到发生冲突的文件以及冲突产生的具体位置 选择需要保留的版本，并删去不需要的内容和额外生成的信息 重新add那些发生冲突的文件，然后commit 后记看到这里，我想有些细心的小伙伴可能会问，还记得最开始有一步——先merge小王的递归版本进master么，喏，你看： 一开始的fib函数 123long long fib(int n) &#123; // To be implemented.&#125; merge进来的小王的fib函数 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 那不是也符合我们之前说的“同一位置的不同内容”，那为什么这个没有造成git的合并冲突呢？那这里我们说，这是因为git的合并冲突是牢牢基于“分支”这个结构的，也就是说，不同的分支要存在并行的关系，才有可能出现“分支冲突”。 我们说小王和小李的代码，逻辑上是呈“并行”结构的——他们都是基于最开始的框架代码所在的master分支checkout出来的，所以合并起来会产生冲突。但也正是这个 基于最开始的框架代码所在的master分支checkout出来的 这个条件，使得小王的递归代码在一开始和master进行merge的时候，它们二者呈现的是一个先后的“顺序”关系而不是一种并行的关系，所以git认为——这是你用新版本去覆盖老版本啊，完全没有问题。所以这样一种先后的串行关系并不会造成“合并冲突”，只有“并行”的分支关系才有可能造成合并冲突。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"第一篇Blog","slug":"第一篇Blog","date":"2022-07-06T15:15:33.000Z","updated":"2022-07-06T16:03:00.573Z","comments":true,"path":"2022/07/06/第一篇Blog/","link":"","permalink":"http://example.com/2022/07/06/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/","excerpt":"","text":"一个并不很介绍的自我介绍 “观看这些使用禄莱相机和樱花牌胶片记录下的彩色影像，随着这些灿烂明亮的颜色，我们似乎对于那个年代的记忆和遐想也鲜活起来。这些照片变成了当下的我们与旧日世界沟通的桥梁。照片中的一切都在不断地重复，照片与照片之间也在不断地交互勾连。秋山亮二让我们看到了一个永远停留在照片上的、上世纪80年代的中国，一个当下社会的“童年”。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。我们也许会惊讶地发现，没有什么会彻底消失，任何消失的东西都会留下痕迹。 秋山亮二让我们看到了一个永远停留在照片上的80年代的中国，一个当下社会的“童年”。而只有通过我们的凝视和思考，这个被封存在影像中的80年代，才能再一次于我们的脑海中浮现。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。 昨日的世界依然以一种隐秘而有力的方式影响着我们的当下。怀旧从来都不仅仅是关于过去，更是关乎我们对当下和未来的理解。” 今年4月清明假期的时候，一时兴起就自己一人到了良渚。上面这段话应该是第二天的行程，拜访良渚文化艺术中心的时候看到的。那时举办的展览叫“你好，小朋友”，印象深刻——虽然提起80年代的共和国，人们应该会有很多好与不好的回忆，但照片里展示出的，小朋友的神采也好，背景里的市容市貌也好，无不呈现出一派生机勃勃的景象。 当然，无论旁人如何论说，回过头去看那一段历史，我想没有人可以否定80年代是一个新旧交替，充满朝气的年代，共和国也好，共和国土地上的人也好，他们都将翻开历史崭新的一页，并走向更加宽阔的舞台，并且迎接属于自己的机遇与挑战。 或许有人会反驳，你这说的滤镜也开得太厉害了，我所认识的80年代根本就不是这个样子，当时我跟你说…… 没错，反驳有理。但这也是我正想说的——记录的重要性。押井守导演的1995版的攻壳机动队有一幕，被Ghost导入虚假记忆的嫌疑犯，在得知自己关于妻子和女儿所有的记忆都是虚构的真相后，也就崩溃了。 “世界上本没有路，走的人多了，也便成了路”，我们从哪里来——取决于我们走过的路；“认识你自己”，我们是谁——取决于我们的经历的记忆。 所以，去记录，便是对围绕“自我”展开的所有议题的尝试解答；去分享，则是探知世界，并寻求一个连接的入口，来导向更多可能性的过程。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"}]}],"categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"理论","slug":"理论","permalink":"http://example.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"OOP","slug":"OOP","permalink":"http://example.com/tags/OOP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]}