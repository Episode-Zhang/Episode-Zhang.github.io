{"meta":{"title":"Episode Zhang's Blog","subtitle":"世界之底的某处自留地","description":"记录想记录的一切","author":"Episode Zhang","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2024-01-02T15:43:26.000Z","updated":"2024-01-02T15:43:08.730Z","comments":true,"path":"aboutme/index.html","permalink":"http://example.com/aboutme/index.html","excerpt":"","text":"👋 先打个招呼吧，你好！很高兴你能阅读我的博客~ 👉 放在前面，关于为什么想写博客：第一篇Blog 😉 更多基本信息： 00年，浙江人，He&#x2F;Him，期望并正在实践着去成为一个包容的人; 23年双非财经院校本科毕业，专业大数据; 现从事软件开发工作，主要负责项目交付中的后端，以及内部自研GIS平台与组件的开发和维护； 喜欢写代码，会觉得实现自己的想法很有意思; 😇 我的价值观：尊重、包容、理性、文明、自由."},{"title":"tag","date":"2022-07-06T12:54:52.000Z","updated":"2022-07-06T16:31:08.209Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"2024年终总结","slug":"2024年终总结","date":"2024-12-31T18:32:16.000Z","updated":"2024-12-31T18:40:43.947Z","comments":true,"path":"2025/01/01/2024年终总结/","link":"","permalink":"http://example.com/2025/01/01/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"0. 引子又到了一年一度的写年终总结的时候了，今年总体给我的感觉可以用“压力+赶路+成长”这三个词的组合来概括——总感觉眨眼间，新的一年就过去了。回望年初的自己，不知是否知道一年后的自己是什么样呢；现在的自己，回望一年前的自己，又是否还能记起当时的心境与盼望呢？所以，在动笔写24年的年终总结时，我回顾了一下23年年终总结时自己的期盼 职业以及技术栈上，“大而全”一定需要让位于“专精”的发展。因此24年的目标之一就是让自己专精地去深入一个领域，定的目标是后端，包括数据库、网络、OS、以及各类中间件和框架的原理了解。 职业规划和技术成长一定不能闭门造车，同行的conference可以多去参加，发挥互联网的力量多找人咨询，之前知乎咨询认识的大V以及交流群的资源用起来，前期认知以及方法论要正确树立。 如此看来，总体而言，24年还是行进在23年所企盼的道路中的。 对于24年的回顾，我想从下面这几个角度来剖析和审视一下自己过去一年的生活： 工作 理论与技能 视野与方法论 最后，再提出我对25年的自己的新的愿景。 1. 工作还记得23年的时候，对自己的期许是“专精”，从这一点上来看，24年确实专精了不少。年初的时候接手了一个中间辗转了好几个团队维护的项目，到我手上已然是“烫手山芋”。但索性最后还是抗住了压力，维护过程中也积累了不少实践经验： 脚本、容器与自动化部署：特别是这种维护周期长，迭代次数多，人员流动频繁的项目，有部署相关的文档和脚本会省力许多，否则连本地起一个环境都十分费力； 线上可观测性：通过prometheus全家桶来打造可观测性系统。可观测系统的好处在于预防和复盘，前者搭配告警系统使用可以很好地防患于未然，后者则是复盘bug的利器，通过对关键指标在事前事中事后的走势的分析，可以做到更好地定位问题，以及评估该类问题对系统的整体影响； 案例：曾经遇到一个问题，场景大抵是OA系统申请最后一天，大量用户登录系统进行填报，结果出现了部分用户反馈系统接口502的情况。当时通过prometheus观测到，在用户反馈前半小时左右，JVM的线程数快速达到了一个峰值，在5分钟过后出现了频繁的full gc，所以我的判断是应用资源不足导致的线程数耗尽不可用。当时的临时做法是关闭系统内其它次要服务，然后调大该OA系统启动脚本中的Xmx参数，再次重启后就没有遇到相同的问题了。 后来复盘时需要排查根本原因，最后排查下来是一个查询用户信息和组织信息的接口在方法里for循环调用了一个Utils类的方法，但这个Utils类的方法是一个远程调用，它调用了用户服务，会去查数据库并返回用户信息。而在for循环里走远程调用导致了慢接口，平时用户量不大的情况下就没问题，但是一旦出现了这种临近关闭申请的场景时，用户量激增把线程数和内存打高，然后JVM启动参数又限制了最大堆内存，结果就一边频繁full gc，另外一边卡在慢接口，外部还有请求堆积，三管齐下导致系统出现了部分用户502的情况。最后调整的方法是，根据用户信息属于热点数据，且场景是读多写少这样一个情况，在远程调用前增加了一层redis缓存，先查缓存，缓存中没有用户信息的情况下再查接口并写缓存。改造后该接口rt下降超50%，同样启动参数的情况下，再也没有出现过系统不可用的情况了。 维护这个项目的时候，我才感觉到能把业务实现出来是最基本的，但决定是代码越写越多，bug越修越多；还是代码越写越少，bug越修越少的，往往在于架构抽象以及devops上花的工夫的多少。良好的抽象和分层，清晰透明和一致的测试与部署，以及完善的监控告警体系，才是一个应用“可用性”的关键。 随后在开发一个老项目的新模块时，我更加坚定了质量把关需要提前做，详细做，好好做的信念。这个项目也是一个类似OA流程的系统，其最关键的就在于“申请-下单”这两个链路的履约。对于履约性质的业务，业界已经有很多成熟的方案了，经过调研后，我认为“状态机”这种基于“状态”与“转移”的建模方式，特别适合这种事件驱动的履约业务的描述，所以我选择了使用基于Spring状态机的实现来完成履约链路的编码。其次，该模块有面向C端的部分，而经过上一次C端OA系统在临近关闭时存在“有流量峰值的可能性”的这一场景的拷打，我决定应该要在实现时就把“可能会存在一定并发量”的情况考虑进去。在这一类OA履约系统中，最重要的就是数值上的一致性——申请的数量，下单的数量，发货的数量必须保持一致性，否则如果影响到了现实中用户的下单和商家的发货，再走补偿成本就会很高了。因此，为了兼容并发场景下的一致性，我在涉及到“申请-下单”链路的所有的表中都添加了乐观锁，同时新增记录也做了幂等性校验的处理，以及事务这种基操性的处理。只是目前来看系统使用量并不大，还没有遇到除了接口压测外的高并发的考验（笑。 最后，临近年底时分配到了数仓开发的任务，场景主要是需要做数据集成，同时涉及到实时和离线，前者主要是物联设备的数据上报、分析、告警；后者是第三方接口定时任务以及部分表同步任务。考虑到实时业务里面国内最流行的框架是flink(主要是我认为用框架风险更小，自己写的话很多涉及到可用性和可靠性的东西如果要深入考虑，至少也得实现一遍这些框架就有的功能，比方说快照容错、精确一次等)，所以我采用了flink来实现数据的etl。同时为了兼容实时和离线，我选择在etl前增加一层接入层，通过统一将数据发送到kafka来整合实时的物联设备数据以及第三方接口的定时任务，然后在数据etl层用kafka+flink来实现数据的统一清洗和写入。表离线同步的部分则通过xxl-job+datax来实现。最后同样上了prometheus全家桶来作为可观测系统。这个项目中我的任务虽然业务上没有复杂的，但在中间件方面确实着实是用得最多的一次——缓存、mq、流处理框架、调度框架以及监控。一方面确实感慨于中间件的带来的效率与稳定性，另一方面也感受到了引入中间件后系统复杂性的提升以及监控的重要性。 总结下来，24年工作上给我的感觉就是，擦的屁股够多，遇到的问题也够多，但同时自己的思考以及应对措施也在这些问题的逼迫下进行了很多。概括而言，那就是，要保证一个应用的可用性，前期的规划设计，核心链路的抽象和建模，系统整体的架构，实现时的分层，以及一致和透明的部署、以及监控和告警体系，是最为关键的部分。 2. 理论与技能技能，或者说“技术”吧，拜工作所赐，感觉自己在Java Curdboy的道路上算是迈出自己的步子了。但是更多的是在碎片时间了解方案，工作时即用即学的方式，主打一个摸爬滚打现学现卖，并没有很好地理解这些技术背后关键的insight以及infrastructure，私以为知乎上有一个问题“计算机的哪些学科是被建议在本科阶段学掉的？”下面的回答很好 你必须知道计算机科学几乎所有的领域基本的想法是什么。比如 tcp 怎么维护虚拟链接传递信息，如何做微观的拥塞控制；编译器怎么 parse 出来 ir，如何对 ir 优化；分布式算法如何协调工作；流式计算里面 unbounded data 怎么做 window&#x2F;trigger；机器学习里面各种模型是如何拟合数据的，为什么需要不同的拟合方式；mysql 中事务怎么做，行锁怎么设计的；linux kernel 的进程调度怎么设计、异步 io 怎么设计…… 有了这些视野之后，你要把它们从具体的领域中抽象成概念。 对比国外顶尖大学的CS教学，就会发现越是顶尖的学校，在教学时越强调insight和intuition的作用，很多时候我们会遗忘细节，但是只要能够记住这么做的动机，也总是能做出一些殊途同归的实现的。因此，在理论和技能这一块，在学习过程中也不要忘了去高屋建瓴地抽象出动机和机制。 另外由于4月份面阿里诚云的时候算法面没过，备受打击，所以算法也刷了一些，截至12月31日top100里通过了81道，还有19道未通过，惭愧… 3. 视野与方法论这一块在今年7月份参加asf asia 2024时，看蚂蚁集团的Nadia的公开演讲时深有感触。她提出了“零散思考-体系化方法论-标准化流程&#x2F;工具”的三步走框架，通过高频输出倒逼自己将零散的思考整合成体系化的方法论，再通过落地将方法论转化为标准化的流程和工具，来形成职业领域的输出的闭环。通过我个人的观察，发现大多数人都停留在“零散思考”这一层级，能够将零散思考转化为方法论的已经是人才了，倘若还能进一步落地成标准化的流程和产品工具，那就是人才中的精英了，这里面每一步都需要大量的观察思考和实践总结。 另外，我通过各类会议还发现了这样一个现象，那就是“汇报(或者叫演讲)”所起到的作用也十分重要，这就涉及到“影响力”的环节了。如果只能把一项技术方案&#x2F;编码实现输出给机器，那么你的工作的影响力最多只能停留在团队内部，最多就是公司范围内；但是如果能把一项技术方案&#x2F;编码实现不仅输出给机器，更能输出给台下的人，那么你的工作的影响力就不仅仅是停留在团队内部了，而是会辐射到整个行业内——后者将帮助你在个人的职业生涯中获取更多的机会。通过观察一些令我印象深刻的演讲人的技术分享，我发现他们共通点就是思维缜密，层次分明，且熟练运用STAR法则——从问题入手来剖析场景，找出关键矛盾，然后指定针对性的方案，最后输出落地的成果，有些则会补充未来的规划等。这样做的好处就是说服力强，能够让人印象深刻，下次遇到了类似的场景，马上就会回忆起演讲者及其分享的方案，从而推动技术模式的推广以及个人的影响力的建设。 4. 愿景新的一年——2025年里，我对自己的愿景是技术上，可以在计算机科学领域更加深入，去补上自己原有在大学课堂里缺失的教育，包括操作系统、网络、数据库、编译原理、以及机器学习和深度学习，最重要的是insight和动手操作；生活上，少熬点夜，养成健康且可持续的生活习惯，同时在身材管理上可以再接再厉(忘记说今年减重10斤了哈哈)；工作上，可以进入一个更大的平台来学习、成长和输出。人么，终归还是要多折腾，才有进步的。 PS：其它除了工作内容上的输出，年中的时候本人所在的公司还经历了一波人事变动，绝大多数人都被干掉了，和我同期的几个转正的实习生只剩我了，原来的leader和所在的组也基本全军覆没。不知道是不是我太过于牛马，以至于让公司觉得性价比太高，所以才让我留下来的呢？想来俗话讲“没有对比就没有伤害”，好像觉得自己无形之中为这些人的离去起到了一些推波助澜的作用。如果那一次我也在裁员名单上的话，也许我现在就在准备润的事宜了吧。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"记一次生产环境下的Full GC导致的服务假死","slug":"记一次生产环境下的Full-GC导致的服务假死","date":"2024-06-30T15:50:19.000Z","updated":"2024-06-30T16:02:38.389Z","comments":true,"path":"2024/06/30/记一次生产环境下的Full-GC导致的服务假死/","link":"","permalink":"http://example.com/2024/06/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Full-GC%E5%AF%BC%E8%87%B4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/","excerpt":"","text":"1. 背景上周五下午15:20分左右的时候，接到用户的反馈说系统进不去。在访问了网站的线上地址后，我发现UI正常渲染，但是所有的接口都报502错误，于是考虑后端服务出现了问题。访问了Grafana监控后，发现后端的服务正常存活，但是出现了Full GC次数变多以及老年代的GC时长飙高的情况： 客户反馈因为周五是系统上报的截止日期，所以存在短期内流量较大的情况。为了尽可能最快地恢复系统并保证服务的可用性，我选择了临时重启服务。在服务重启完毕后，接口恢复正常并持续工作了一段时间。但是在下午15:40左右，又接到了部分用户对系统不可用的反馈。在与客户协商并取得同意后，我选择临时关闭了生产环境机器上的一些次要服务来为当前服务腾出资源，同时去调高分配给当前服务的最大堆内存的大小以及新生代区的大小，启用了G1垃圾回收器，最后保障了此后服务的可用性。 由于造成服务假死的原因有很多，所以需要进一步地梳理和复盘才能确认出服务不可用的原因。下面的“复盘”环节将给出各个时间节点系统的一些指标的情况并结合相对应的表现去试图还原系统走向假死的这一个过程。 2. 复盘通过抓取和分析当天的系统与服务的指标，以及相对应的系统外在的表现，按照时间顺序可以罗列出以下的几个重要时间点： 下午15:05分左右出现了JVM线程数的一个峰值，峰值时JVM线程数达到2.6K的一个量级； 下午15:10分左右，老年代内存接近占满，然后开始频繁触发Full GC，同时Full GC的时长也开始增加，15:10分左右的一次标记清除算法耗时达到了507毫秒； 与此同时系统CPU使用率开始飙高，从平时峰值10%多变成了40%多(时间用的UTC+0所以差8个小时)； 下午15:22分接到用户反馈，称系统无法正常使用，核实后发现系统接口均报502错误； 下午15:25分完成系统的第一次重启，重启后接口正常工作； 下午15:40分左右系统又出现了JVM线程数的新峰值，量级在2.8k，同时接到部分用户反馈系统不可用的情况； 下午16:03分，关闭了生产机节点上的次要服务，同时调整服务的启动参数，完成了系统的第二次重启，此次重启后系统没有再发生不可用的情况； 最后解决问题的思路整体上遵循“临时扩容”的办法，将分配给Java服务的资源调大后问题就没有再出现了——而原先该服务的Java进程的启动参数中，分配给该服务的最大堆内存为1024M。这说明我们系统不可用的原因定位到的位置是应用层，发生的问题可以归纳为资源耗尽。同时，在事后排查接口访问与耗时这一块相关的数据时，我们发现出现服务不可用的时候系统的QPS并不高（只有个位数），同时系统的用户服务的接口中，有三个接口的耗时均达到了5s以上： sysUser/listByUser：平均耗时11.2s sysUser/list：平均耗时6.82s sysUser/listByOrganization：平均耗时5.67s 因此，当时系统的情况可以概括为：系统的JVM线程数飙高，堆内存耗尽，频繁Full GC的同时QPS并不高。推测原因是这些慢调用在系统流量较大时，将大量的线程阻塞住，导致一方面老的请求尚在处理，新的请求过来后，SpringBoot内置的Tomcat容器不得不启动新的线程去处理请求，新的请求进来的速度远高于已有请求的处理速度，最后资源耗尽，最终服务不可用。 3. 几个接口为什么慢既然我们定位到了接口的慢调用导致了流量较大时系统大量线程被阻塞，就需要去查看相关的代码，做了哪些操作可能引起如此高的耗时。 以listByUser为例，我们排查这个接口的实现逻辑后，最终定位到这样一处for循环： 12345678910111213for (UserOrganizationRelation userOrganizationRelation : sysUserList) &#123; String userInfo = SzsnApiUtil.getUserInfo(userOrganizationRelation.getUserId(), request); JSONObject jsonObject1 = (JSONObject) JSONObject.parse(userInfo); Integer code = (Integer) jsonObject1.get(&quot;code&quot;); if (code.equals(200)) &#123; JSONObject dt = (JSONObject) jsonObject1.get(&quot;data&quot;); JSONObject user = (JSONObject) dt.get(&quot;user&quot;); if (user != null &amp;&amp; !StringUtils.isBlank(user.get(&quot;nickName&quot;).toString())) &#123; userOrganizationRelation.setUserName((String) user.get(&quot;nickName&quot;)); userOrganizationRelation.setPhoneNumber((String) user.get(&quot;phonenumber&quot;)); &#125; &#125;&#125; 这里的sysUserList是根据事先传入的角色参数查到的对应角色下的所有用户的user_id组成的一个entity列表。在for循环内部，代码其实就是做了两件事： 获取String类型的userInfo变量； 解析String类型的userInfo变量，并将解析出来的属性赋给sysUserList中的实体； 这里的userInfo的获取调用了一个叫SzsnApiUtil的静态方法，结合类名以及拿到userInfo并转换成JSONObject(实际上就是在做反序列化)的行为且根据code属性是否等于200来做后续的逻辑来看，大概率获取userInfo的过程就是一次远程调用的过程。只不过这个远程调用我们实现稍微封装了一下。如果可以验证SzsnApiUtil.getUserInfo方法内部就是一个远程调用用户服务的接口，那么我们等于是在for循环内去执行远程调用，那么接口耗时如此之高，能达到10s以上，也就解释得通了。最后，在查看SzsnApiUtil.getUserInfo的内部实现逻辑后，我们发现该方法就是一次裸的远程调用。 同样的道理，在查看了另外两个耗时较高的接口的内部实现逻辑后，也发现了for循环内执行远程调用的情况，这也就能解释得通为何这三个接口的平均耗时如此之高。 4. 优化接口性能我们知道，计算机在访问存储的时候是按照“由近及远”的方式的，越是近的，读取的速度就越快。从CPU内的寄存器里读取一次数据，在现代CPU上可以在不到1纳秒之内完成(1个时钟周期)，而从CPU的L3 Cache读取一次数据，再到RAM中读取一次数据，在现代硬件上耗时也都是纳秒级的；但是如果需要从硬盘上读取数据，哪怕是SSD，耗时都起码在微秒级；如果涉及到网络I&#x2F;O，那么耗时从毫秒到秒就不等了。可想而知，在for循环里发起网络调用，将会给系统带来多大的负担。一旦遇到突发的流量，并发数稍稍高于平时，这些慢调用就可以把本来可以用于处理外部请求的线程阻塞在I&#x2F;O上，进而导致可用线程大大减少，JVM不得不创建更多的线程来处理请求。而线程的创建，对象的创建都是有开销的，只限定1个G的堆内存，外面还有流量进来，里面的线程还在被慢调用独占，一来一去，服务最终资源耗尽，出现了假死。 仔细分析这个场景，其实我们不难想出一种合理且简便的优化方法——用户数据是一个典型的“读多写少”的数据，我们访问系统的服务时，经常需要查询用户数据，但是往往我们修改用户数据的次数远小于读取的次数，一个用户可能每天都会访问系统，但很少说用户每天都要修改用户信息。因此，针对这一种读多写少、且本身为热点数据需要被系统大量其它服务访问、且I&#x2F;O方式都是通过网络调用来实现的数据，我们完全可以引入缓存去做数据读写的优化。 例如，我们在读取用户信息时，首先从缓存中查找数据，如果缓存命中，我们直接返回缓存中的数据；如果缓存未命中，我们发起一起网络调用来获取用户信息，同时将获取到的信息写入缓存，方便下次查询时直接返回。在后端服务中，缓存常用的选型有远程缓存Redis&#x2F;Memcached，以及本地缓存例如Guava缓存甚至Java内置的Map。这里选用Redis来作为缓存，毕竟Redis操作简单、效率好且提供了很多开箱即用的功能，不占用Java服务的内存，如果将来服务做多实例也无需进行大量相关的改造。 改造后的代码如下： 1234567891011121314151617181920if (redisUtil == null) &#123; // 该方法内部加了互斥锁用于保证仅初始化一次 initRedisUtil();&#125;// 设置缓存过期时间为15分钟long expireTime = 15 * 60;// 查询缓存String key = String.format(&quot;getUserInfo-%s&quot;, userId);String userInfo = (String) redisUtil.get(key);log.info(&quot;getUserInfo: 查询用户&#123;&#125;命中缓存！&quot;, userId);// 如果缓存不存在, 则调用远程接口, 然后写缓存if (userInfo == null) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;userId&quot;, userId); // callStr内部封装了http请求过程，调用的接口地址做了脱敏 userInfo = callStr(&quot;/user-service/api/v1/user/get&quot;, &quot;POST&quot;, map, request); redisUtil.set(key, userInfo, expireTime); log.info(&quot;getUserInfo: 查询用户&#123;&#125;缓存未命中, 已写入重新写入缓存！&quot;, userId);&#125;return userInfo; 这里将缓存时间设置成了15分钟，主要是考虑了在突发流量的情况下，15分钟的窗口就能避免相当多的请求去走远程调用；如果流量不密集，两次请求时间超过15分钟，那么即便缓存过期了，系统内还是有充足的线程余量来处理请求。但这样做也带来了数据不一致的风险，假设用户在15分钟的窗口内修改了用户数据，那么用户服务是不会同步写Redis的，此时用户再访问系统拿到的就是旧的数据。针对这种情况，我留了一个后门接口来删除Redis内所有保存的用户信息的缓存来做兜底。 接口优化后，依赖于这个SzsnApiUtil.getUserInfo的三个接口耗时基本有两倍以上的提升(相同的时间下同一接口调用次数至少是之前的2倍)，以上周六到当前为止作为时间窗口来检查接口调用耗时： 优化完成后，这周一下午四点到五点之间也有一波短暂的流量峰值，这一次系统完全能够正常工作。 除了接口优化以外，考虑到内存管理上尽量避免产生过多的碎片影响大对象的分配和保存，项目的服务是基于JDK 8的，因此后续还将JVM的GC收集器从CMS收集器换成了G1收集器。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"问题排查","slug":"问题排查","permalink":"http://example.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}]},{"title":"记一次容器OOM引起的接口404错误","slug":"记一次容器OOM引起的接口404错误","date":"2024-02-15T19:43:45.000Z","updated":"2024-02-15T20:17:36.267Z","comments":true,"path":"2024/02/16/记一次容器OOM引起的接口404错误/","link":"","permalink":"http://example.com/2024/02/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%B9%E5%99%A8OOM%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A5%E5%8F%A3404%E9%94%99%E8%AF%AF/","excerpt":"","text":"1. 背景1.1 环境首先列出系统环境以及相关组件的版本： 系统：阿里云2C4G轻量应用服务器-ubuntu20.04； docker：24.0.5； 服务： python：3.10； python package： sanic&#x3D;&#x3D;22.6.1； websockets&#x3D;&#x3D;10.0； SpeechRecognition&#x3D;&#x3D;3.10.1； requests-toolbelt&#x3D;&#x3D;1.0.0； requests&#x3D;&#x3D;2.31.0； vosk&#x3D;&#x3D;0.3.45； 1.2 业务背景业务上预期实现一个“智能问答”的模块，其中包含一项功能：由用户输入语音，将其识别成文字后交给大模型进行处理，最后将用户的语音提问以及大模型输出的回答一并呈现在前端对话框。 该项目的后端服务基于python，而本人被分配到的任务则是基于vosk的中文语音识别模型以及SpeechRecognition包和sanic框架来实现“用户输入的语音到对应文字的识别”的web接口。对于该接口，其路径为/api/audio/convert，预期从请求的body体中读取wav格式的音频字节流，并返回识别后的中文文本。 在本地进行开发时，本人采用的前后端通信的架构如下： 前端所有的api请求会先发送到nginx网关上，对应本机端口8080； 在nginx网关中设置路由规则，然后将前端的请求转发到实际处理的后端服务对应的端口8091上； 后端服务采用docker容器进行部署，后端服务在容器内的进程端口映射到本机的8091端口上； 即简单的“前端-网关-后端”的这样一个单体应用的架构。 1.3 问题在基于1.2的业务背景的基础上，遇到的问题可以整理为： 前端调用测试接口/test时，得到预期结果； 录入语音并调用/api/audio/convert接口时，在接口等待一段时间后返回错误码404； 跳过网关，直接请求接口/test与/api/audio/convert，返回错误码502； 2. 排查过程遇到这类问题，笔者本人最先考虑的是首先是前端发起的请求能否正常到达服务，其次是是否服务本身出现了问题，所以沿着这个思路，笔者先做了以下的排查工作： 首先查看网关是否能够正常接收前端发起的请求： 查看nginx的access.log与error.log，发现nginx能够正常接收前端发起的请求； 查看容器是否正常运行： docker ps查看docker容器运行情况，发现容器正常运行； 查看容器内服务是否正常运行： docker logs查看docker容器中的服务日志，发现日志打印了一部分收到请求后预期打印的内容，同时日志并未打印任何程序异常； 检查到这里，可以首先确认容器正常运行，同时前端的请求的确到达了网关，并由网关正确地转发到了相应的后端服务上，后端服务接收到请求后执行了部分相应的处理逻辑，但并没有走完全程。这中间应该是发生了异常的退出，但却没有被业务逻辑以及web框架自身捕捉到这个发生的异常。再结合请求这个/api/audio/convert接口时产生了较长的等待，于是考虑是否存在机器资源耗尽从而导致请求失败的可能性。 于是到阿里云的控制面板里查看监控，发现在接口请求期间，机器出现： 内存发生了断崖式地下降； 磁盘高频读； 如图： 结合先前对容器服务产生“异常退出”的可能性的判断，高度考虑服务进程大量占用内存，系统内存耗尽导致对应的进程被内核OOM kill掉，所以整个服务挂掉，为接口调用失败的原因。 为了验证猜测，首先重启容器，并且重复先前的操作，使用top命令以及free -h命令观察对应进程的资源占用： 发现后端的服务进程确实产生了大量的内存占用，最后使用dmesg -T命令，查看是否真的产生了系统级的OOM，发现的确发生了OOM，如图： 至此，我们可以说OOM是板上钉钉，证据确凿的事情了——也就是说 我们后端的服务在运行期间占用了大量的内存，导致系统oom，进程被干掉导致服务挂掉，从而导致接口报错。 这里面比较有意思的是，具体执行任务的进程是对应docker容器进程的孙辈进程，因而该进程被oom kill掉后不会影响容器进程的运行，所以查看容器运行状态时，可以看到容器运行正常。 最后，发现是python服务调用的模型自身文件有2.1个G的大小，机器本身仅有4g的内存，因此将其从磁盘上读入内存时，容易造成机器内存耗尽的问题。最后换了一个轻量级的，60多M的模型，之后接口就正常工作了。 3. 结论与收获这是一个非常典型的因为资源耗尽导致系统oom kill掉服务进程，从而导致整个服务挂掉，接口调用失败的案例。排查这类问题首先要做好的就是各级各层的日志与监控需要具备(系统的可观测性)，这样才可以逐步缩小问题范围；同时对排查的问题范围要有敏感度，接口调用失败有可能是接口本身不够健壮，运行过程中产生了异常，也有可能是系统层面的问题，如进程导致系统资源耗尽从而被内核kill掉——而前者一般是可以通过服务应用的日志观察到的，后者需要进一步借助系统层面的观测。 从具体的“术”的层面，大致学习到了： top -p命令查看具体进程的系统资源占用； free命令查看系统内存的使用情况，本文中使用free -h命令； dmesg命令可以查看系统内核日志，本文中使用dmesg -T命令； *4. 延伸与思考笔者认为，从这篇文章出发，顺带着延伸开来，也可以试着学习和思考一下以下几个问题： docker的虚拟化的机制是怎么样的？ 为什么用ps -ef命令查看的时候，显示的是：docker容器一个进程A，容器内image写Dockerfile时run的python src/main.py一个进程B，最后调用的python是宿主机上的/usr/local/bin/python，这个python对应的一个进程/usr/local/bin/python src/main.pyC，并且ABC的关系是：A为B父，B为C父； 对于更加复杂的微服务架构以及分布式系统，这样的系统的可观测性有没有什么实践案例，是怎么设计和做的？ 这里的解决方法是采用更轻量的模型，部分也是受制于笔者本人对本地开发环境的预算以及公司基建的不成熟，假如服务器资源更充足，要求在不降低模型质量的前提下，对应的解决方法又该如何设计和实现？","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"问题排查","slug":"问题排查","permalink":"http://example.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}]},{"title":"2023年终总结","slug":"2023年终总结","date":"2024-01-02T15:20:07.000Z","updated":"2024-01-02T15:49:35.955Z","comments":true,"path":"2024/01/02/2023年终总结/","link":"","permalink":"http://example.com/2024/01/02/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"0. 引子其实早在12月初就已经有了动笔23年年终总结的念头了，但是总感觉23年剩下的最后的日子里还会有新的盼望与涟漪，不想就此对整年盖棺定论，又或者是懒和拖延，就到了24年1月1日才开始着手写这份年终总结了。如果用一个词来概括过去的23年，我想是——“杂乱”：23年最开始的那几天，抱着“阳”后初愈的身体，放弃了考研，来到了现在所在的公司进行实习，负责一项全新业务0-1的探索和验证；中途又经历了转正、公司大量裁员、部门架构调整、业务变动，切身感受到了所谓的“寒气”；开启了个人在杭州的全新生活，告别了一些人，也遇到了新的人……2023年，便是我试图从“杂乱”中理出头绪，用软件工程的话来讲，便是管理“生活”的复杂度的一年。 接下来，我想从下面的几个角度 事：在2023年一年里，我在工作和生活中做了哪些事情； 人：2023年令我印象深刻的人，以及我和他们的故事； 情感：2023年我如何将自我的希冀与盼望投向另一个个体，以及得出的结论； 反思与目标：对2023年全年所经历的人事进行回顾和反思，并且确定24年的目标与期望； 来概括一下23年做了哪些事，以及有怎样的收获和感想。 1. 事1.1 工作3月份之前，主要是熟悉web gis那一套技术栈，包括前端三件套基础加上cesium.js，mapbox.js这一类web gis开发中常用的包。为了解决前端加载倾斜摄影慢的问题，研究了一下如何使用nginx作为客户端缓存，以及对应的请求策略。因为之前完全没有web开发的背景知识，所以经此一役算是算是快速入门web开发了。 3月份-7月份则开始研究数字孪生相关的领域知识并且产出用于内部迭代的原型。“数字孪生”于我而言，给我的感觉是“仿真模拟”的新瓶装旧酒，当然彼时同行时新这玩意儿。于是开始学习和使用Unreal引擎这套技术栈，蓝图和C++那一部分算是入了一点门，因为UE的自带体系，学习这一部分的时候倒是有种学方言的感觉（雾。顺带学了一点时髦的games101，当然学完三维变换，做完第二个assignment，到反走样那一章就没继续下去了。 本来作为全年任务的数字孪生，7月结束后就算是到达了一个里程碑了，8月份部门组织架构调整，我从中台调到了项目组。8月用React+Taro写了一个简易的地图小程序，虽然路径规划功能还没写完就被另有安排了，但这个过程中倒是把React简单入了个门，俗话说会JavaScript以及useState和useEffect就能干活（大雾。期间对比了一下Vue和React，都是简单使用后的体会，个人而言虽然前者自动挡省事，但还是手动挡给到的及时反馈和满足感更加强烈些。 9月打杂修bug，以及做原型。10月临时接手和支撑一个历史悠久的项目，个人职责是主要作为后端进行CURD。期间也参加了绝大多数的需求评审，给我的感觉是产品的想法永远都是尽善尽美最好十全十美的（笑），以及学习了会上扯皮和简化需求等为自己争取时间和空间的必要性和技巧。在作为整个项目支撑的后端之间，感觉到难的部分在于表设计（因为业务流程相对不难理解，并发和用户量也不大），需要充分理解业务需求和流程，以及有一定的项目经验，设计出的表才会比较符合实际需求以及健壮；同时开发流程和规范也十分重要，整个项目初期有原型、设计方案、任务排期和追踪表、版本管理说明等一系列稳定，但在经历了几轮人员和技术栈更替后就几尽丢光了。期间还差点出岔子，项目在汇报演示的时候我和前端同学还在改代码，但是汇报演示时用的是本地开发环境的数据，差点导致已有的功能都无法交付，索性有备份，直接回滚到最近一次的备份，万事大吉虚惊一场。。 11月接到了一个复杂项目，涵盖了线上商城-仓储-加工-物流-财务-本地便民服务一系列应用模块，当然我在这其中主要的职责是业务逻辑梳理、文档编写、代码原型验证。算是简单跟了一遍此类类似系统的业务逻辑，下游B&#x2F;C端用户执行交易并生成订单，订单流转到仓储系统，然后拣货-出货，接着流转到物流系统，进行车辆与人员的调度，最后收货方收到货物，完成订单，整个过程中的单据和流水保存在财务系统。仓储可以异步进行原材料的采购，也可以异步接受加工模块产出的次级产成品的出入库调度。整个应用基于中台微服务的基建，用到了包括单点登录与鉴权、网关、Kafka消息中心等技术，当然我并没有进行深度参与，也算是遗憾。 12月年底，项目交付的任务逐渐进入尾声，工作的中心又逐渐转向内部GIS平台和技术的优化，主要是功能的扩展这一方面。 1.2 毕设受迟先生与一众db佬的影响，也是CS相关的专业课只深入学习了伯克利的CS61B数据结构的影响，毕业设计打算用Java做一个简单的kv数据库，支持CURD、区间索引和持久化。表使用了手搓的红黑树，参考了之前学习红黑树时自己写的笔记（当然笔记也是参考的算法导论和算法4）；索引也是手搓的B+树，参考的是奶牛书。这一部分其实是暑假论文里就做得差不多的内容，毕设主要把持久化做了一下，用了最简单的Java Serialization的writeObject和readObject那一套，以及一个简单的用来parse命令行用户输入指令的parser。整个业务流程是数据进来先写缓冲区，待缓冲区满或命令行程序退出后将数据落盘，支持命令行的CURD与查看表视图的命令。 因为自己造轮子，所以基本上不怎么需要降重，同时可能做的领域比较独特（相对其他同学做的web管理系统，数据分析和可视化，AI相关），所以答辩完后评了优秀，当然这个数据库本身我认为啥也不是（笑）。当然，作为一个玩具玩玩，还是非常考验编码和设计水平的，做完以后也很有成就感。 1.3 生活实习公司找到后，就在附近自己租了一个单间，起先觉得能睡觉就好，所以就找了一间7平也不到的房间，桌子都没有，用的是折叠床上桌凑合的。但也正是那段时间，自认为是适应最快的时期。转正后又过了一段时间，大概8月这样子，换了一间稍大的单间，有桌子和飘窗，顿时感觉生活明媚了很多（侧面证明了住处对人身心的影响 雾）。然后就是定期打扫卫生，整理房间，大致如此。 前半年周末基本都是留给自己的，下半年开始周末总会有多多少少的邀约，当然我也不太擅长拒绝人，事后觉得自己总是在满足别人的行程，却疏于了自我建设。 2. 人2.1 同事因为裁员，所以23年一整年的基调基本都是在送别。和我同期的实习生只有我留了下来，部门唯一的一位女同事，人也很好，称呼她为yf姐吧——告诉我她在请婚假的当天被hr约谈辞退，让我意识到了确实不该对公司抱有太多期待。令我印象最深刻的是10月过来的一位工大的同学，工位在我旁边。我自认为自己没做什么，相比之下。但她临走时送了我一份离别礼，打开是一支香薰和几包泥土和种子，贺卡上她叫我小师傅，说很高兴认识我，因为我让她的实习生活快乐翻倍。我很感动，我会觉得被需要和记得，同时被大方地告知和传递这份需要和传递时很满足。 2.2 F哥6月份的时候，和母亲公司的CEO一起聚了一餐，期间她介绍我认识了其中一位聚美优品的联合创始人，就称呼他为F哥吧。F哥，以及和他背景经历类似的人，都给我一种素养见识过硬，思维敏捷，同时兴趣和爱好也十分广泛，“会玩”的感觉。因为本身背景的差异，我并没有向他请教太多技术上和细节的问题，更多的是“方向”和“价值”一类的话题。通过彼此的交流，我感受到顶尖的人能够全神贯注地听你说的每一句话每一个词，并且真的试图100%地理解，例子就是每次这类人的反问都会让你感到棘手，你必须对你所谈及的话题中的内容的每个细节都了如指掌，才能cover和handle这类反问，他们在视图填充逻辑链上那一处你视图模糊或无意带过的关键帧。而“会玩”，更多地是给我一种这样的人对某一类事物有自己的品味、标准以及支撑这一切的动机和信念。最后，我还记得他的结论——尽早找到自己正反馈的来源。 2.3 室友W8月份换了新的单间后认识了新的室友，就称呼她为W同学吧。她和我一样也是23届毕业生，那之后我和她会分享吃喝、生病了我会把自己开过的药拿出来询问是否能用得上，etc。当然她也会分享自己的吃的喝的，当然，每次都是精准地在我提供了一些什么东西的时候。我在想是不是我的这种分享会给人一种无形的压力呢，如果W同学的信条是有来必有往的话。 某个休息日，碰巧我母亲给我寄了她去潮汕游玩后带回来的当地特色牛肉丸和牛筋丸，又叠加W同学生病。于是我做芹菜白萝卜丸子汤的时候多做了一点，分了W同学一些；后面我甲流的时候没力气下楼，她说做了玉米排骨汤面，让我也分一点。后来，她说年前可能就回南京了，下家找好了，年后入职。 3. 情感12月的最后一天在深圳见了大学同学兼好友，上一次单独见面是21年了，就称呼她为一同学吧。前一天晚上吃饭，她和我分享自己的各位搭子，后来我想我是什么搭子呢，不过答案如果知道了可能反而会没意思吧，我始终觉得人和人之间的关系，如果彼此能产生联系，至少我应该抱着“亲历”和“共进”的态度去面对和相处。我想人面对陌生环境总是要有一个融入的过程的，就像我满怀希望地来到一个地方，却发现位子都已坐满了人，那我要么悻悻地回去，要么焦急地询问和踌躇地盼望是否还会有人离开，是否还会有新的座位。人在一个环境中，其实也是一个“找位置”的过程。一同学和我说了很多在陌生的城市见到故人、在新的学校求学的感受，彼时我还没太多感受，或许是我没有一个像现在一样的时间去沉淀自己思绪的机会。 后来，她看到深圳当代艺术与城市规划馆里的那句“来了就是深圳人”很兴奋。晚饭的时候，一同学和我分享她的室友来深圳的那一天，我便即兴唱了Eason的《好久不见》，她沉默、然后流眼泪（后来一同学补充是自己说到动情处流眼泪的），我不知道该做啥，大概是凭借着习惯吧，我没说啥，只是起身拿纸，顺便留意一同学桌上用完的纸巾，多了的话要扔掉。 希望她也能找到自己的归属，心之所向，素履以往。 情感这种东西，我越是现在越觉得“会表达”的重要性，如果传递不到，那便只能是自我感动，所以我现在很多时候都不试图故意压抑自己了，开心、中意、留恋、以及自以为是的捧哏和搞怪，我都会直接表达和展示出来，当然可能生气和不满我还是会有所选择地保留。 今天我和我妈说，人还是要有个性和自我一点，不要围着另一个人转。 4. 反思与目标4.1 工作的目的和态度最开始，我对于工作的态度是二十分认真，因为我想借由工作上的成果证明自己，那些我写的代码，出自我手的工程，就像是我的孩子，是我一手带大的。 再后来，经历了几次argue之后，我发现工作的出发点是“问题导向”的，而其核心要点在于“目标导向”。这一整套链路不短，个人所处的位置可能和个人的愿景并不匹配。有些人定义什么算“问题”，有些人制定问题的“解”，有些人调度资源并执行“解”，而这一整个过程本身也是递归的。或许我想着我所定义的“问题”，我所制定的“解”，但到我手上的只是作为“执行”的那部分工作，并且为了解决不由你定义的“问题”和“解”，还需要你做出妥协。这一过程是痛苦的，尤其是当你投入五十分热情，三十分认真，二十分执行的时候，结果不一定有十分的评价。某种程度上这和“感情”模块中提到的一样： “如果传递不到，那便只能是自我感动” 正好公司裁员的一些民间消息传过来后，我就觉得，确实人不该对自己能够依靠但又没经过太多检验的东西保有太高的期望，大家相互索取和付出，谁也不亏欠谁是最好的，自我感动就是一种内耗。 由此，我得到的第一个教训是，工作时自己做的事情和预期是一方面，是否能够搞清楚工作背后的逻辑以及match leader的期望，以及能够如实且贴切地汇报出来，又是另一方面。关注目标，拉通对其，拿到结果，保证产出，在工作本身没有太多的附加价值时，保证这些就OK了。 4.2 个人的精力规划最近在看《精力管理》，对里面的一个观点颇为认同，大意为过去的基于时间进行个人事项管理的观点认为生活就像一场长跑，但基于精力进行个人事项管理的观点认为，生活其实更应该像一场场的短跑冲刺——区别在于，前者时间跨度长，关注的愿景远，会引导人性中“遇到复杂就拖延”这一弱点；后者通过间歇性地短跑冲刺和体能恢复，能够促成更高的执行率以及更加及时的回馈。 23年一年熬了很多夜，通宵应该也通了几次，我自我评估，自己也是一旦精力处于专注和充沛的区间，就会想着达成某件事，不管实际上外界处于哪个时间端，深夜还是午后。但往往这么做，后面几天就会产生补偿式地注意力涣散和对娱乐的需求，换言之——短跑了，冲刺了，但没好好休息。所以24年的一个目标就是改善自己的精力管理结构，允许短跑冲刺，但要及时补充休息。这一点具体执行的计划和规则后续再明确一下。 以及，锻炼和健身对精力的恢复确实有用，以往会觉得自己上了一天班很累了，应该回去休息；但是往往这个时候去健身房，练完一轮下来以后，感觉诶，仿佛自己就得到了休息。之前不知道哪里看到的观点，出处不可考，只凭记忆，说，当人的大脑向人体发出倦怠、效率下降、注意力不集中的指令时要重视，这个时候大脑的意思是，停止你“手头上”的事——意味着你可以换一件不同的事情做做，此时大脑是可以得到一定程度的休息和放松的。所以健身和锻炼的习惯需要继续保持下去。 4.3 职业规划根据之前走的知乎的咨询，职业以及技术栈上，“大而全”一定需要让位于“专精”的发展。因此24年的目标之一就是让自己专精地去深入一个领域，定的目标是后端，包括数据库、网络、OS、以及各类中间件和框架的原理了解。在此基础上去谋求认可度与成长空间更大的职位以及更高的薪水。 职业规划和技术成长一定不能闭门造车，同行的conference可以多去参加，发挥互联网的力量多找人咨询，之前知乎咨询认识的大V以及交流群的资源用起来，前期认知以及方法论要正确树立。 这里最重要的是，让事情开始做起来，为此可能需要牺牲一些社交的时间，但这是值得的。当纠结的时候，一定回想自己之前说的： 人还是要有个性和自我一点，不要围着另一个人转。 建立自己的价值，追求自己的生活，每个人都是自己的第一负责人，相信真的朋友可以理解你。 最后，如果有前往文明国家的愿景，请在职业规划的计划完成并且已经在执行的过程中时再考虑，国内个人的成长空间还可以再榨一榨，追求自我价值的建立和传递永远是第一位的。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"第一个小型项目的感想","slug":"第一个小型项目的感想","date":"2022-10-13T15:15:15.000Z","updated":"2022-10-13T16:07:12.628Z","comments":true,"path":"2022/10/13/第一个小型项目的感想/","link":"","permalink":"http://example.com/2022/10/13/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%84%9F%E6%83%B3/","excerpt":"","text":"心路历程趁着学校的专业实践2(最终结果是要交一篇论文)，其实本可以拿之前的课程论文交差了事的，但是想了一下，这也是一个不错的机会，可以让回顾并且总结一下过去所学的知识，并且去尝试将其组装成一个小小的成果出来。 大概自己一部分是菜再加上人还是略佛，另一部分也是个人在学习知识时总是倾向于深度优先，一个点卡住就会想疯狂搞懂，再加上还有考研的准备，，所以直到现在，补齐基础的进度也还是停留在CS 61B 21sp的过半这个位置吧。但仔细回顾起来，其实学到的已经不少了：线性表以及其基于数组和引用的实现，各类树形结构(并查集、二叉堆、平衡树)以及其基于引用和数组的实现etc。我认为自己能独立地把这些知识的内容从intuition到相互之间的联系再到代码的实现讲个八九不离十(个别特别变态的内容可能要准备下——说的就是你，红黑树！)。 写过文档码过代码，结合优秀的课程的知识导入结构与体系的建立与梳理，才能让自己去真正地理解并运用所学的内容。 最开始的时候，我想，要不专业实践2做一个数据结构可视化的项目吧。但是考察了一下，如果简单地取考虑这个项目的需求，那只是调用一下类似于graphviz这种的成熟库以及在此基础上封装api，就能做出个大概来；如果想要相对复杂一些的功能，例如把可视化的实现和具体的语言进行独立，自己做一套简单的，支持循环语句，函数定义和递归调用的语言，然后后台解析用户的指令并生成相应的图形，那就需要编译原理的知识了，但显然对于若干个星期的时间来说，不足以完成这一目标。 于是我的第一个想法就陷入了，简单的话太简单，难的话又太难的局面。于是我想着，有没有更好的方案，其所需要的知识是我学过的，但是实现起来又需要自身对所学知识的深入理解以及良好的设计和编码风格才能完成的项目——于是，一个简单的KV存储系统便成为了我的考虑目标。用红黑树来作为表结构，B+树作为索引，并且在前台有简单的调度系统，来管理数据的读写和处理以及内存和磁盘的交互，这样，既实现了知识内容是基于所学范围的，同时实现起来又有一定难度的目标。 结果最后时间所限，实现了表和索引结构，以及在纯内存场景下的，数据读写和存储的调度。还差磁盘和内存的交互以及把调度模块进行独立地抽象和模块化。 心得始终要保持对项目整体的把握感我认为第一点，也是最重要的一点是，要时刻保持对项目整体的“把握感”。这种把握感在于： 你对项目整体的构思和设计是怎样的，它有可能会在不远的未来发生变动么？ 如果会，变动的频繁程度怎么样？ 每次变动涉及到的变化量，你的预估是多少？ 以及对应地，你该如何进行复杂度的管理？ 你当前的工作处于项目整体的什么位置？ 你所开发的内容，是为了满足整体中的哪一部分的需求？ 会涉及到哪些组件&#x2F;模块的依赖？ 以及随着你当前的工作，项目整体的架构是否会发生改变？ 可以看到，这里有两个不同的抽象层需要兼顾——整体以及局部。其所处的位置不同，但又相互影响，处理不好的结果，那就是当项目的量级达到一定程度后，再要维护时发现复杂度爆炸。 除了项目有抽象上的复杂度需要维护，人脑也有自己的复杂度。工作在local和global时，人脑的context是不一样的，当项目整体的规模够大时，每次context switching带来的开销也够咱喝一壶的。 因此，个人认为，解决之道是在项目开发的时候，documenting的工作也需要实时跟进且不能过于马虎。要做到 叙述项目整体的构建以及主要模块的工作、之间的依赖、以及交互的方式； 分层记录开发流程与进度，维护一个进度树。这样工作在local时，记录和维护较低层的进度信息；local工作完成时，返回祖先层更新进度，同时查看接下来的任务以及回溯整体的开发情况； 在发生重构时(例如在开发子模块时发现可以或需要进行全局性的改动)，也是顺着工作树进行调整； 这样，整个开发的流程和工作有一个较为系统的组织，也方便管理，可以弥补项目中后期复杂度增加以及人脑上下文切换带来的巨大开销所造成的复杂性的增加。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"继承的隐患","slug":"继承的隐患","date":"2022-07-22T16:58:44.000Z","updated":"2024-02-15T20:12:37.275Z","comments":true,"path":"2022/07/23/继承的隐患/","link":"","permalink":"http://example.com/2022/07/23/%E7%BB%A7%E6%89%BF%E7%9A%84%E9%9A%90%E6%82%A3/","excerpt":"","text":"简单回顾一下什么是“继承”“继承(inheritance)”是OOP中重要的一个概念，它可以用于代码复用，也可以用于需要提供多态的场合。当我们“提起”继承时，往往用“is-a”的关系来类比，并将其与组合(composition)要求的“has-a”关系来进行对比：比如我们说“汽车”是“载具”，所以“载具”有的一切属性和行为“汽车”也应该具有；同时“汽车”有“轮胎”，不同的汽车可能拥有不同材质、不同数量、不同造价、不同品牌的轮胎。显而易见我们不能倒过来说“汽车有载具”或者是“汽车是轮胎”，那会引发逻辑以及实践的混乱。Java中用extends关键字来表示“继承”， 1public class A extends B &#123;...&#125; 来表示“类A is-a 类B”的关系，并且A将继承B中所有的属性、方法和内嵌的类(但无法访问被private关键字修饰的)。类A可以有自己专属属性、方法，也可以重写B内的方法。 为什么用OOP——为编程提供抽象在谈继承的隐患之前，先说下为什么要使用OOP。OOP是一种建模的思想，它将任意一项活动视为不同的对象(Object)进行一系列通信与交互的结果。每个对象拥有并维护自己内部的状态，并且对外具有一系列行为可以影响自己或者其它对象的状态。 这样做的一个好处就是，对象是一个已经抽象化了的个体——大多数时候我们无需了解对象内部的实现原理，只需要调用对象的方法就可以完成我们的任务，此即“拿来主义”。这样，不同的程序员可以工作在不同的抽象层级：负责基件的程序员工作在一个抽象程度较低的层次，在“机器”这一级别上压榨出更多的性能；负责应用层的程序员则使用开发好的基件模块来搭建应用程序，并将使用情况与遇到的问题反馈给前一层，他们自己本身无需care基件的底层实现；负责具体业务的工作人员则在搭建好的平台中进行相关操作，当然，他们也不用担心自己的应用是怎么使用的。 这一种每一层都封装自己内部的实现细节，对外暴露特定功能的接口，为上层使用者提供抽象的模式，极大地提高了开发效率，节约了很多程序员宝贵的时间。 继承的潜在“隐患”——破坏封装和抽象性一种常见的说法是，在大多数场合下，尤其是需要代码复用的场合，尽量使用“组合”而非“继承”，除非是需要用到多态特性的场合。这其中的理由是，使用“继承”会提高不同模块间的“耦合度”，从而导致代码可维护性的减弱。 这个说法是有道理的，我们先举个例子来说明“封装”是如何提高“耦合度”，进而埋下“隐患”的。 首先是两个非常简单的类，其中VerboseDog类继承Dog类： 1234567891011// 基类 Dogpublic class Dog &#123; public void bark() &#123; System.out.println(&quot;bark&quot;); &#125; public void barkMany(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; bark(); &#125; &#125;&#125; 12345678910// 派生类 VerboseDogpublic class VerboseDog extends Dog &#123; @Override public void barkMany(int n) &#123; System.out.println(&quot;As a dog, I say: &quot;); for (int i = 0; i &lt; n; i++) &#123; bark(); &#125; &#125;&#125; 乍一看，非常简单，不是么？Dog类只有两个方法，所有的功能都只是向控制台输出文本内容；而VerboseDog类也就重写了barkMany方法，在重复输出“bark”前向控制台多打印了一句“As a dog, I say: ”而已，这会有什么问题呢？那请看—— 倘若有一天，维护Dog类的人重构了一遍Dog类，这个程序员抱着“一切循环皆丑陋，世间至善是递归”的信仰，把Dog类写成如下的形式： 12345678910111213// 重构后的 Dog 类public class Dog &#123; public void bark() &#123; barkMany(1); &#125; public void barkMany(int n) &#123; if (n == 0) &#123; return; &#125; System.out.println(&quot;bark&quot;); barkMany(n - 1); &#125;&#125; 重构之后的Dog类仍然保持与重构前相同的功能，从使用者的视角上看，既无增减也无其它改动。尽管其具体实现与原来的已经不相同了。这个时候，如果再调用VerboseDog类的barkMany方法，就会报“StackOverflow”的错误——可是明明改动之前好好的啊。原来，仔细一看就会发现，VerboseDog重载过的barkMany方法，会和未重载的bark方法相互调用对方并且没有退出机制，这一来一去也就栈溢出了。 当然，在这个例子中，问题不难分析，bug也很好改。但这个简单的例子已经让我们看到，使用“继承”会让我们的派生类对基类“依赖度”变高，用专业点的话来说，就是会提高基类和派生类之间的“耦合”，为了修改自己写的派生类的代码，很有可能不得不去把基类的代码全部都读一遍并且分析一遍，当然，这是比较痛苦的。 有关“继承”与“组合”的取舍另外一个例子(会需要一点数据结构的知识，只到线性表这部分就够了)则展示了对“继承”和“组合”的选择与取舍，考虑基于“List”的“Stack”，简化起见，我们 只考虑Stack的push方法怎么实现； List接口规定所有List的实现都必须有“add”方法； List的实现有基于引用的LinkedList和基于数组的ArrayList。 下面我们分三种情况来分别实现这个需求： 使用继承is-a的 12345public class ExtensionStack&lt;T&gt; extends LinkedList&lt;T&gt; &#123; public void push(T item) &#123; this.add(x) // add 方法是父类 LinkedList 中本就有的 &#125;&#125; 使用组合has-a，但类型写死的 123456public class DelegationStack&lt;T&gt; &#123; private LinkedList&lt;T&gt; _items; // 使用 LinkedList 作为组件 public void push &#123; _items.add(x); &#125;&#125; 使用组合has-a，但允许用户在初始化时自定义使用哪种List的 123456789public class StackAdapter&lt;T&gt; &#123; private List&lt;T&gt; _item; // 使用 List 作为组件 public StackAdapter(List&lt;T&gt; item) &#123; _item = item; &#125; public void push &#123; _item.add(x) &#125;&#125; 对于第一种实现，我们默认Stack作为一种特殊的LinkedList，在LinkedList已有的基础上来实现Stack的push方法。显然，这里继承的使用让LinkedList“已有的基础”几乎完全暴露给了我们。我们需要心里门清Stack继承了LinkedList的哪些方法，其中哪些使我们在Stack中可以访问的，哪些是不能访问的，等等。这些都要求我们至少要去读过LinkedList的源码并且知道主要内容和重要细节。 对于二三种而言，我们都可以默认把对应的List当做一个完整的组件，只使用其具有的功能，而不必过于关注它的实现。从抽象的角度而言，后者要更高些。第二第三种具体的区别就是，写死LinkedList类型可以让我们利用一些LinkedList中特有的方法(如果必要)，只提供List层级的抽象的话，可以在调用时提供更多的灵活性，但是能利用到的List的特性是最为基础的那几个。 上面的都只是一些利弊分析，基于“继承”的实现虽然可能会导致开发时因为耦合度变高导致项目的可维护性降低，但是换来的好处就是对多态的支持，比如在java里，我完全可以拿Stack去做Vector的事情(虽然有时候不太提倡，但事实上它的实现允许你这么干)。按理说一个Stack所支持的操作应该是在顶部进行push和pop，但是实际上完全可以做在任意合法位置插入和删除的事情，比如下面代码(已省略非重要环节，例如定义类和导入相关模块之类的)。 1234567Vector&lt;String&gt; s = new Stack&lt;String&gt;();s.add(&quot;Hello&quot;);s.add(&quot;my&quot;);s.add(&quot;World&quot;);s.add(1, &quot;hi&quot;);s.remove(1);System.out.println(s); 在Java中能够编译通过并且运行(openjdk 18)，然后输出以下结果 [Hello, my, World] 所以具体到开发而言，如何取舍就是仁者见仁智者见智的事情了。 BTW，从前面的例子就能得以窥见，java中Stack的实现是我们说的第一种，基于“继承”来实现的，后面我们会贴出openjdk的实现来进行分析；而c++中无论是gcc系、MSVC系、还是clang系，对stl的stack的实现是基于我们后面说的二三两种，基于“组合”来实现的。下面简单贴个源码，只选取了关键部分： 12345678910111213141516171819202122232425// openjdk 对 Stack 的实现// @source https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/Stack.javapublic class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; // 这里extends了Vector，说明Stack是作为Vector的继承来实现的，上面的例子也证明了这一点 public Stack() &#123; &#125; public E push(E item) &#123; addElement(item); return item; &#125; public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; 1234567891011121314151617181920212223242526272829// llvm-clang 对 Stack 的实现，只摘取源文件中对 Stack 的描述// @source https://github.com/llvm/llvm-project/blob/main/libcxx/include/stack// 源文件中这些都是注释，是为了帮助理解和阅读但不是实现本身namespace std&#123;template &lt;class T, class Container = deque&lt;T&gt;&gt;class stack // 没有声明继承&#123;public: typedef Container container_type; // 使用具有默认值可变类型参数 typedef typename container_type::value_type value_type; typedef typename container_type::reference reference; typedef typename container_type::const_reference const_reference; typedef typename container_type::size_type size_type;protected: container_type c; // 这里只是使用了默认为 deque&lt;T&gt; 类型的容器来实现 stackpublic: /* 已省略各种构造函数 */ bool empty() const; size_type size() const; reference top(); const_reference top() const; void push(const value_type&amp; x); void push(value_type&amp;&amp; x); template &lt;class... Args&gt; reference emplace(Args&amp;&amp;... args); // reference in C++17 void pop(); void swap(stack&amp; c) noexcept(is_nothrow_swappable_v&lt;Container&gt;)&#125;;/* 省略一堆我还看不懂的模板和函数 */ 实际上java.util包里的Stack的实现招致过一些批评，还有人指出自己作为面试官，对方在面试时如果使用到java.util里的Stack的话，是作为一个极大的减分项(negative point)来对待的(出处：Java 程序员，别用 Stack？！)。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"理论","slug":"理论","permalink":"http://example.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"OOP","slug":"OOP","permalink":"http://example.com/tags/OOP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"git合并冲突","slug":"git合并冲突","date":"2022-07-10T17:08:40.000Z","updated":"2024-02-15T20:11:51.399Z","comments":true,"path":"2022/07/11/git合并冲突/","link":"","permalink":"http://example.com/2022/07/11/git%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/","excerpt":"","text":"什么是合并冲突(merge conflict)想象你和小王都是同一个开源项目的贡献者，这一天你拉取了远程仓库的最新版本，但是git却报出了一个错误： 自动合并 xxx冲突（内容）：合并冲突于xxx自动合并失败，修正冲突然后提交修正的结果。 你仔细一看，原来是你上一次commit时的“utils.java”的实现被小王重构并且优化了一下，并且小王也将这个“utils.java”给push到了远程仓库。这样，远程仓库的“utils.java”的内容，和你自己本地分支最新commit的“utils.java”的内容出现了不一致。git的merge能自行解决一部分差异，但另一部分相同位置出现的不同实现就无法被git的自动merge解决了，因为这个时候git就不知道，你是想要保留自己的，还是要保留小王的版本，于是就这样git报出了合并冲突的错误。 所谓“**合并冲突(merge conflict)**”，便是git在合并两个分支的时候，出现了对同一处位置的不同内容。大部分时候git都能自动完成merge工作，但一旦出现上述的同一位置的不同内容的情况，git就会“犯难”，它并不知道该保留哪一处分支的内容，此时就会出现“分支冲突”的错误，并把冲突的解决交给用户。 一个简单的实例现在我们来看一个简单的合并冲突的实例。 比如我现在想要布置一个“实现斐波那契数列第n项求解”的任务，我在一开始就初始化了一个git仓库，并且在默认的分支master上给出了代码的基本框架并且提交了一个commit： 新建工作目录，初始化git仓库 123mkdir merge-conflict-demo # 在当前目录新建一个名为“merge-conflict-demo”的目录cd merge-conflict-demo # 进入这个目录git init. # 在这个进入的目录下初始化一个git仓库 给出“求解斐波那契数列第n项”的基本代码框架 1touch fibonacci.cpp # 新建一个cpp源文件用来求解斐波那契数列的第n项 1234567891011121314// 求解斐波那契数列第n项的代码框架#include &lt;iostream&gt;long long fib(int n) &#123; // To be implemented.&#125;int main() &#123; std::cout &lt;&lt; &quot;请输入一个正整数：&quot;; int n; std::cin &gt;&gt; n; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; fib(n) &lt;&lt; std::endl; return 0;&#125; 提交代码 12git add fibonacci.cppgit commit -m &quot;Provide skeleton of Fibonacci series evaluation by cpp&quot; 这样子git的仓库就有包含代码框架的commit了。现在比方说有两个学生小王和小李，他们接到的任务就是函数long long fib(int n)的具体实现。 小王说，这还不简单，我根据定义写个递归就行，于是他： 基于初始commit创建了自己的分支，并且进行了fib的递归实现 1git checkout -b wang-implementation 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 简单测试并通过了样例以后，小王提交了代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation recursively&quot; 小李一开始也是这么想的，但小李发现这么写会产生很多的重复计算，比如计算“fib(n)”的时候，按递归定义计算了“f(n-2)”；但计算“fib(n-1)”的时候按递归定义又要重新把“fib(n-2)”算一遍，会导致更多不必要的开销。深思熟虑以后，小李决定： 基于初始commit创建了自己的分支，并完成了fib的迭代实现 1git checkout -b li-implementation 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 通过了测试并提交了自己的代码 12git add fibonacci.cppgit commit -m &quot;Implement Fibonacci series evaluation iteratively&quot; 于是我现在首先merge了小王的代码，然后git成功把我的“fibonacci.cpp”更新成了小王的递归版(记得我自己默认的分支最开始就是master)： 当我看完小王的实现后，觉得没毛病，所以我现在想看小李的实现。于是我把小李的实现merge了进来，git就报出了合并冲突的bug： 造成合并冲突的原因在第一部分已经有讲过了，要合并分支的commit和当前分支所记录的commit里存在对同一位置的不同内容，这个时候git会报出合并冲突并把选择权交给用户。反映到这里，就是小王和小李在“fibonacci.cpp”文件的long long fib(int n)这个函数的实现里选择了不同的方式，让git在合并时感到了“为难”。 合并冲突问题的解决还是第二部分的例子——在合并冲突的文件“fibonacci.cpp”中，我们可以看到git为它生成了一些额外的信息： 123456789101112131415long long fib(int n) &#123;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);======= // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li-implementation&#125; 我们对这些信息进行一点解释说明 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 表示当前分支记录的内容，在这里就是因为一开始commit的就是小王的递归版本，所以“&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD”下面保存的就是小王的实现。 ======= 分隔符，用来区分当前分支的内容与merge进来的分支的内容。 &gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名] 从“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”到“&gt;&gt;&gt;&gt;&gt;&gt;&gt; [merge进来的分支名]”之间的内容，表示merge进来的分支所记录的内容，在这里就是小李所实现的基于迭代的fib函数。 要解决分支冲突，我们需要对保留当前还是接受merge的内容进行取舍。因为显然小李的实现更加高效，所以我们选择保留小李的实现，并且删去小王的实现以及git生成的助记符，然后进行add与commit。 1234567long long fib(int n) &#123; // 小李的迭代实现 int a = 1, b = 1; for (int i = 2; i &lt;= n; i++) b = b + a, a = b - a; return b;&#125; 如图所示，经过上述的步骤后，我们已经成功解决了合并冲突，并且HEAD指针指向master分支，最近的一次commit显示我们把小李的分支merge进了master分支。 综上所述，进行分支冲突修复的办法就是： 找到发生冲突的文件以及冲突产生的具体位置 选择需要保留的版本，并删去不需要的内容和额外生成的信息 重新add那些发生冲突的文件，然后commit 后记看到这里，我想有些细心的小伙伴可能会问，还记得最开始有一步——先merge小王的递归版本进master么，喏，你看： 一开始的fib函数 123long long fib(int n) &#123; // To be implemented.&#125; merge进来的小王的fib函数 1234567long long fib(int n) &#123; // 小王的递归实现 if (n == 0 || n == 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 那不是也符合我们之前说的“同一位置的不同内容”，那为什么这个没有造成git的合并冲突呢？那这里我们说，这是因为git的合并冲突是牢牢基于“分支”这个结构的，也就是说，不同的分支要存在并行的关系，才有可能出现“分支冲突”。 我们说小王和小李的代码，逻辑上是呈“并行”结构的——他们都是基于最开始的框架代码所在的master分支checkout出来的，所以合并起来会产生冲突。但也正是这个 基于最开始的框架代码所在的master分支checkout出来的 这个条件，使得小王的递归代码在一开始和master进行merge的时候，它们二者呈现的是一个先后的“顺序”关系而不是一种并行的关系，所以git认为——这是你用新版本去覆盖老版本啊，完全没有问题。所以这样一种先后的串行关系并不会造成“合并冲突”，只有“并行”的分支关系才有可能造成合并冲突。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"第一篇Blog","slug":"第一篇Blog","date":"2022-07-06T15:15:33.000Z","updated":"2022-07-06T16:03:00.573Z","comments":true,"path":"2022/07/06/第一篇Blog/","link":"","permalink":"http://example.com/2022/07/06/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/","excerpt":"","text":"一个并不很介绍的自我介绍 “观看这些使用禄莱相机和樱花牌胶片记录下的彩色影像，随着这些灿烂明亮的颜色，我们似乎对于那个年代的记忆和遐想也鲜活起来。这些照片变成了当下的我们与旧日世界沟通的桥梁。照片中的一切都在不断地重复，照片与照片之间也在不断地交互勾连。秋山亮二让我们看到了一个永远停留在照片上的、上世纪80年代的中国，一个当下社会的“童年”。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。我们也许会惊讶地发现，没有什么会彻底消失，任何消失的东西都会留下痕迹。 秋山亮二让我们看到了一个永远停留在照片上的80年代的中国，一个当下社会的“童年”。而只有通过我们的凝视和思考，这个被封存在影像中的80年代，才能再一次于我们的脑海中浮现。无论是否经历过那段历史，我们总能在其中找到属于我们自己的记忆。 昨日的世界依然以一种隐秘而有力的方式影响着我们的当下。怀旧从来都不仅仅是关于过去，更是关乎我们对当下和未来的理解。” 今年4月清明假期的时候，一时兴起就自己一人到了良渚。上面这段话应该是第二天的行程，拜访良渚文化艺术中心的时候看到的。那时举办的展览叫“你好，小朋友”，印象深刻——虽然提起80年代的共和国，人们应该会有很多好与不好的回忆，但照片里展示出的，小朋友的神采也好，背景里的市容市貌也好，无不呈现出一派生机勃勃的景象。 当然，无论旁人如何论说，回过头去看那一段历史，我想没有人可以否定80年代是一个新旧交替，充满朝气的年代，共和国也好，共和国土地上的人也好，他们都将翻开历史崭新的一页，并走向更加宽阔的舞台，并且迎接属于自己的机遇与挑战。 或许有人会反驳，你这说的滤镜也开得太厉害了，我所认识的80年代根本就不是这个样子，当时我跟你说…… 没错，反驳有理。但这也是我正想说的——记录的重要性。押井守导演的1995版的攻壳机动队有一幕，被Ghost导入虚假记忆的嫌疑犯，在得知自己关于妻子和女儿所有的记忆都是虚构的真相后，也就崩溃了。 “世界上本没有路，走的人多了，也便成了路”，我们从哪里来——取决于我们走过的路；“认识你自己”，我们是谁——取决于我们的经历的记忆。 所以，去记录，便是对围绕“自我”展开的所有议题的尝试解答；去分享，则是探知世界，并寻求一个连接的入口，来导向更多可能性的过程。","categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"}]}],"categories":[{"name":"blogs","slug":"blogs","permalink":"http://example.com/categories/blogs/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/tags/%E6%9D%82%E6%96%87/"},{"name":"经验碎碎念","slug":"经验碎碎念","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"问题排查","slug":"问题排查","permalink":"http://example.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"理论","slug":"理论","permalink":"http://example.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"OOP","slug":"OOP","permalink":"http://example.com/tags/OOP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]}